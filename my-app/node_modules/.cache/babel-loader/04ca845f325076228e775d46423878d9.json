{"ast":null,"code":"import { inArray, isString, prop } from '../common';\nimport { StateObject } from './stateObject';\n\nvar StateQueueManager =\n/** @class */\nfunction () {\n  function StateQueueManager(router, states, builder, listeners) {\n    this.router = router;\n    this.states = states;\n    this.builder = builder;\n    this.listeners = listeners;\n    this.queue = [];\n  }\n\n  StateQueueManager.prototype.dispose = function () {\n    this.queue = [];\n  };\n\n  StateQueueManager.prototype.register = function (stateDecl) {\n    var queue = this.queue;\n    var state = StateObject.create(stateDecl);\n    var name = state.name;\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name)) throw new Error(\"State '\" + name + \"' is already defined\");\n    queue.push(state);\n    this.flush();\n    return state;\n  };\n\n  StateQueueManager.prototype.flush = function () {\n    var _this = this;\n\n    var _a = this,\n        queue = _a.queue,\n        states = _a.states,\n        builder = _a.builder;\n\n    var registered = [],\n        // states that got registered\n    orphans = [],\n        // states that don't yet have a parent registered\n    previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\n    var getState = function (name) {\n      return _this.states.hasOwnProperty(name) && _this.states[name];\n    };\n\n    var notifyListeners = function () {\n      if (registered.length) {\n        _this.listeners.forEach(function (listener) {\n          return listener('registered', registered.map(function (s) {\n            return s.self;\n          }));\n        });\n      }\n    };\n\n    while (queue.length > 0) {\n      var state = queue.shift();\n      var name_1 = state.name;\n      var result = builder.build(state);\n      var orphanIdx = orphans.indexOf(state);\n\n      if (result) {\n        var existingState = getState(name_1);\n\n        if (existingState && existingState.name === name_1) {\n          throw new Error(\"State '\" + name_1 + \"' is already defined\");\n        }\n\n        var existingFutureState = getState(name_1 + '.**');\n\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.router.stateRegistry.deregister(existingFutureState);\n        }\n\n        states[name_1] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      var prev = previousQueueLength[name_1];\n      previousQueueLength[name_1] = queue.length;\n\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  };\n\n  StateQueueManager.prototype.attachRoute = function (state) {\n    if (state.abstract || !state.url) return;\n    var rulesApi = this.router.urlService.rules;\n    rulesApi.rule(rulesApi.urlRuleFactory.create(state));\n  };\n\n  return StateQueueManager;\n}();\n\nexport { StateQueueManager };","map":{"version":3,"mappings":"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","names":["inArray","isString","prop","StateObject","router","states","builder","listeners","StateQueueManager","queue","stateDecl","state","create","name","Error","hasOwnProperty","map","push","flush","registered","orphans","previousQueueLength","getState","_this","notifyListeners","length","forEach","listener","s","self","shift","name_1","result","build","orphanIdx","indexOf","existingState","existingFutureState","stateRegistry","deregister","attachRoute","splice","prev","abstract","url","rulesApi","urlService","rules","rule","urlRuleFactory"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\state\\@uirouter\\core\\state\\stateQueueManager.ts"],"sourcesContent":["import { inArray, isString, prop } from '../common';\nimport { _StateDeclaration } from './interface';\nimport { StateObject } from './stateObject';\nimport { StateBuilder } from './stateBuilder';\nimport { StateRegistryListener } from './stateRegistry';\nimport { Disposable } from '../interface';\nimport { UIRouter } from '../router';\n\nexport class StateQueueManager implements Disposable {\n  queue: StateObject[] = [];\n\n  constructor(\n    private router: UIRouter,\n    public states: { [key: string]: StateObject },\n    public builder: StateBuilder,\n    public listeners: StateRegistryListener[]\n  ) {}\n\n  dispose() {\n    this.queue = [];\n  }\n\n  register(stateDecl: _StateDeclaration) {\n    const queue = this.queue;\n    const state = StateObject.create(stateDecl);\n    const name = state.name;\n\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n      throw new Error(`State '${name}' is already defined`);\n\n    queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    const { queue, states, builder } = this;\n    const registered: StateObject[] = [], // states that got registered\n      orphans: StateObject[] = [], // states that don't yet have a parent registered\n      previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n    const getState = (name) => this.states.hasOwnProperty(name) && this.states[name];\n    const notifyListeners = () => {\n      if (registered.length) {\n        this.listeners.forEach((listener) =>\n          listener(\n            'registered',\n            registered.map((s) => s.self)\n          )\n        );\n      }\n    };\n\n    while (queue.length > 0) {\n      const state: StateObject = queue.shift();\n      const name = state.name;\n      const result: StateObject = builder.build(state);\n      const orphanIdx: number = orphans.indexOf(state);\n\n      if (result) {\n        const existingState = getState(name);\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n\n        const existingFutureState = getState(name + '.**');\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.router.stateRegistry.deregister(existingFutureState);\n        }\n\n        states[name] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      const prev = previousQueueLength[name];\n      previousQueueLength[name] = queue.length;\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  }\n\n  attachRoute(state: StateObject) {\n    if (state.abstract || !state.url) return;\n    const rulesApi = this.router.urlService.rules;\n    rulesApi.rule(rulesApi.urlRuleFactory.create(state));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}