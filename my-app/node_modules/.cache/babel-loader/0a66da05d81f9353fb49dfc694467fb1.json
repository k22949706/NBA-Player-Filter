{"ast":null,"code":"import { applyPairs, extend, identity, inherit, mapObj, noop, omit, tail, values, copy } from '../common/common';\nimport { isArray, isDefined, isFunction, isString } from '../common/predicates';\nimport { stringify } from '../common/strings';\nimport { is, pattern, pipe, prop, val } from '../common/hof';\nimport { Resolvable } from '../resolve/resolvable';\nimport { services } from '../common/coreservices';\n\nvar parseUrl = function (url) {\n  if (!isString(url)) return false;\n  var root = url.charAt(0) === '^';\n  return {\n    val: root ? url.substring(1) : url,\n    root: root\n  };\n};\n\nfunction nameBuilder(state) {\n  return state.name;\n}\n\nfunction selfBuilder(state) {\n  state.self.$$state = function () {\n    return state;\n  };\n\n  return state.self;\n}\n\nfunction dataBuilder(state) {\n  if (state.parent && state.parent.data) {\n    state.data = state.self.data = inherit(state.parent.data, state.data);\n  }\n\n  return state.data;\n}\n\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n  return function urlBuilder(stateObject) {\n    var stateDec = stateObject.self; // For future states, i.e., states whose name ends with `.**`,\n    // match anything that starts with the url prefix\n\n    if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n      var newStateDec = {};\n      copy(stateDec, newStateDec);\n      newStateDec.url += '{remainder:any}'; // match any path (.*)\n\n      stateDec = newStateDec;\n    }\n\n    var parent = stateObject.parent;\n    var parsed = parseUrl(stateDec.url);\n    var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n      state: stateDec\n    });\n    if (!url) return null;\n    if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error(\"Invalid url '\" + url + \"' in state '\" + stateObject + \"'\");\n    return parsed && parsed.root ? url : (parent && parent.navigable || root()).url.append(url);\n  };\n};\n\nvar getNavigableBuilder = function (isRoot) {\n  return function navigableBuilder(state) {\n    return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;\n  };\n};\n\nvar getParamsBuilder = function (paramFactory) {\n  return function paramsBuilder(state) {\n    var makeConfigParam = function (config, id) {\n      return paramFactory.fromConfig(id, null, state.self);\n    };\n\n    var urlParams = state.url && state.url.parameters({\n      inherit: false\n    }) || [];\n    var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n    return urlParams.concat(nonUrlParams).map(function (p) {\n      return [p.id, p];\n    }).reduce(applyPairs, {});\n  };\n};\n\nfunction pathBuilder(state) {\n  return state.parent ? state.parent.path.concat(state) :\n  /*root*/\n  [state];\n}\n\nfunction includesBuilder(state) {\n  var includes = state.parent ? extend({}, state.parent.includes) : {};\n  includes[state.name] = true;\n  return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\n\n\nexport function resolvablesBuilder(state) {\n  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n  var objects2Tuples = function (resolveObj, resolvePolicies) {\n    return Object.keys(resolveObj || {}).map(function (token) {\n      return {\n        token: token,\n        val: resolveObj[token],\n        deps: undefined,\n        policy: resolvePolicies[token]\n      };\n    });\n  };\n  /** fetch DI annotations from a function or ng1-style array */\n\n\n  var annotate = function (fn) {\n    var $injector = services.$injector; // ng1 doesn't have an $injector until runtime.\n    // If the $injector doesn't exist, use \"deferred\" literal as a\n    // marker indicating they should be annotated when runtime starts\n\n    return fn['$inject'] || $injector && $injector.annotate(fn, $injector.strictDi) || 'deferred';\n  };\n  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\n\n  var isResolveLiteral = function (obj) {\n    return !!(obj.token && obj.resolveFn);\n  };\n  /** true if the object looks like a provide literal, or a ng2 Provider */\n\n\n  var isLikeNg2Provider = function (obj) {\n    return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));\n  };\n  /** true if the object looks like a tuple from obj2Tuples */\n\n\n  var isTupleFromObj = function (obj) {\n    return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));\n  };\n  /** extracts the token from a Provider or provide literal */\n\n\n  var getToken = function (p) {\n    return p.provide || p.token;\n  }; // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable\n\n\n  var literal2Resolvable = pattern([[prop('resolveFn'), function (p) {\n    return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy);\n  }], [prop('useFactory'), function (p) {\n    return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy);\n  }], [prop('useClass'), function (p) {\n    return new Resolvable(getToken(p), function () {\n      return new p.useClass();\n    }, [], p.policy);\n  }], [prop('useValue'), function (p) {\n    return new Resolvable(getToken(p), function () {\n      return p.useValue;\n    }, [], p.policy, p.useValue);\n  }], [prop('useExisting'), function (p) {\n    return new Resolvable(getToken(p), identity, [p.useExisting], p.policy);\n  }]]); // prettier-ignore\n\n  var tuple2Resolvable = pattern([[pipe(prop('val'), isString), function (tuple) {\n    return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy);\n  }], [pipe(prop('val'), isArray), function (tuple) {\n    return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy);\n  }], [pipe(prop('val'), isFunction), function (tuple) {\n    return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy);\n  }]]); // prettier-ignore\n\n  var item2Resolvable = pattern([[is(Resolvable), function (r) {\n    return r;\n  }], [isResolveLiteral, literal2Resolvable], [isLikeNg2Provider, literal2Resolvable], [isTupleFromObj, tuple2Resolvable], [val(true), function (obj) {\n    throw new Error('Invalid resolve value: ' + stringify(obj));\n  }]]); // If resolveBlock is already an array, use it as-is.\n  // Otherwise, assume it's an object and convert to an Array of tuples\n\n  var decl = state.resolve;\n  var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n  return items.map(item2Resolvable);\n}\n/**\n * A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\n\nvar StateBuilder =\n/** @class */\nfunction () {\n  function StateBuilder(matcher, urlMatcherFactory) {\n    this.matcher = matcher;\n    var self = this;\n\n    var root = function () {\n      return matcher.find('');\n    };\n\n    var isRoot = function (state) {\n      return state.name === '';\n    };\n\n    function parentBuilder(state) {\n      if (isRoot(state)) return null;\n      return matcher.find(self.parentName(state)) || root();\n    }\n\n    this.builders = {\n      name: [nameBuilder],\n      self: [selfBuilder],\n      parent: [parentBuilder],\n      data: [dataBuilder],\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: [getUrlBuilder(urlMatcherFactory, root)],\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: [getNavigableBuilder(isRoot)],\n      params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n      // Each framework-specific ui-router implementation should define its own `views` builder\n      // e.g., src/ng1/statebuilders/views.ts\n      views: [],\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: [pathBuilder],\n      // Speed up $state.includes() as it's used a lot\n      includes: [includesBuilder],\n      resolvables: [resolvablesBuilder]\n    };\n  }\n\n  StateBuilder.prototype.builder = function (name, fn) {\n    var builders = this.builders;\n    var array = builders[name] || []; // Backwards compat: if only one builder exists, return it, else return whole arary.\n\n    if (isString(name) && !isDefined(fn)) return array.length > 1 ? array : array[0];\n    if (!isString(name) || !isFunction(fn)) return;\n    builders[name] = array;\n    builders[name].push(fn);\n    return function () {\n      return builders[name].splice(builders[name].indexOf(fn, 1)) && null;\n    };\n  };\n  /**\n   * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n   * properties and API built.\n   *\n   * @param state an uninitialized State object\n   * @returns the built State object\n   */\n\n\n  StateBuilder.prototype.build = function (state) {\n    var _a = this,\n        matcher = _a.matcher,\n        builders = _a.builders;\n\n    var parent = this.parentName(state);\n\n    if (parent && !matcher.find(parent, undefined, false)) {\n      return null;\n    }\n\n    for (var key in builders) {\n      if (!builders.hasOwnProperty(key)) continue;\n      var chain = builders[key].reduce(function (parentFn, step) {\n        return function (_state) {\n          return step(_state, parentFn);\n        };\n      }, noop);\n      state[key] = chain(state);\n    }\n\n    return state;\n  };\n\n  StateBuilder.prototype.parentName = function (state) {\n    // name = 'foo.bar.baz.**'\n    var name = state.name || ''; // segments = ['foo', 'bar', 'baz', '.**']\n\n    var segments = name.split('.'); // segments = ['foo', 'bar', 'baz']\n\n    var lastSegment = segments.pop(); // segments = ['foo', 'bar'] (ignore .** segment for future states)\n\n    if (lastSegment === '**') segments.pop();\n\n    if (segments.length) {\n      if (state.parent) {\n        throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n      } // 'foo.bar'\n\n\n      return segments.join('.');\n    }\n\n    if (!state.parent) return '';\n    return isString(state.parent) ? state.parent : state.parent.name;\n  };\n\n  StateBuilder.prototype.name = function (state) {\n    var name = state.name;\n    if (name.indexOf('.') !== -1 || !state.parent) return name;\n    var parentName = isString(state.parent) ? state.parent : state.parent.name;\n    return parentName ? parentName + '.' + name : name;\n  };\n\n  return StateBuilder;\n}();\n\nexport { StateBuilder };","map":{"version":3,"mappings":"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","names":["applyPairs","extend","identity","inherit","mapObj","noop","omit","tail","values","copy","isArray","isDefined","isFunction","isString","stringify","is","pattern","pipe","prop","val","Resolvable","services","parseUrl","url","root","charAt","substring","nameBuilder","state","name","selfBuilder","self","$$state","dataBuilder","parent","data","getUrlBuilder","$urlMatcherFactoryProvider","urlBuilder","stateObject","stateDec","match","newStateDec","parsed","compile","isMatcher","Error","navigable","append","getNavigableBuilder","isRoot","navigableBuilder","getParamsBuilder","paramFactory","paramsBuilder","makeConfigParam","config","id","fromConfig","urlParams","parameters","nonUrlParams","params","map","concat","p","reduce","pathBuilder","path","includesBuilder","includes","resolvablesBuilder","objects2Tuples","resolveObj","resolvePolicies","keys","token","deps","undefined","policy","annotate","fn","$injector","strictDi","isResolveLiteral","obj","resolveFn","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","getToken","literal2Resolvable","dependencies","tuple2Resolvable","tuple","slice","item2Resolvable","r","decl","resolve","items","resolvePolicy","matcher","urlMatcherFactory","find","parentBuilder","parentName","builders","views","resolvables","StateBuilder","array","length","push","splice","indexOf","key","hasOwnProperty","chain","parentFn","step","_state","segments","split","lastSegment","pop","join"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\state\\@uirouter\\core\\state\\stateBuilder.ts"],"sourcesContent":["import { applyPairs, extend, identity, inherit, mapObj, noop, Obj, omit, tail, values, copy } from '../common/common';\nimport { isArray, isDefined, isFunction, isString } from '../common/predicates';\nimport { stringify } from '../common/strings';\nimport { is, pattern, pipe, prop, val } from '../common/hof';\nimport { StateDeclaration } from './interface';\n\nimport { StateObject } from './stateObject';\nimport { StateMatcher } from './stateMatcher';\nimport { Param } from '../params/param';\nimport { UrlMatcherFactory } from '../url/urlMatcherFactory';\nimport { UrlMatcher } from '../url/urlMatcher';\nimport { Resolvable } from '../resolve/resolvable';\nimport { services } from '../common/coreservices';\nimport { ResolvePolicy } from '../resolve/interface';\nimport { ParamDeclaration } from '../params';\nimport { ParamFactory } from '../url';\n\nconst parseUrl = (url: string): any => {\n  if (!isString(url)) return false;\n  const root = url.charAt(0) === '^';\n  return { val: root ? url.substring(1) : url, root };\n};\n\n/**\n * A function that builds the final value for a specific field on a [[StateObject]].\n *\n * A series of builder functions for a given field are chained together.\n * The final value returned from the chain of builders is applied to the built [[StateObject]].\n * Builder functions should call the [[parent]] function either first or last depending on the desired composition behavior.\n *\n * @param state the _partially built_ [[StateObject]]. The [[StateDeclaration]] can be inspected via [[StateObject.self]]\n * @param parent the previous builder function in the series.\n */\nexport type BuilderFunction = (state: StateObject, parent?: BuilderFunction) => any;\n\ninterface Builders {\n  [key: string]: BuilderFunction[];\n\n  name: BuilderFunction[];\n  parent: BuilderFunction[];\n  data: BuilderFunction[];\n  url: BuilderFunction[];\n  navigable: BuilderFunction[];\n  params: BuilderFunction[];\n  views: BuilderFunction[];\n  path: BuilderFunction[];\n  includes: BuilderFunction[];\n  resolvables: BuilderFunction[];\n}\n\nfunction nameBuilder(state: StateObject) {\n  return state.name;\n}\n\nfunction selfBuilder(state: StateObject) {\n  state.self.$$state = () => state;\n  return state.self;\n}\n\nfunction dataBuilder(state: StateObject) {\n  if (state.parent && state.parent.data) {\n    state.data = state.self.data = inherit(state.parent.data, state.data);\n  }\n  return state.data;\n}\n\nconst getUrlBuilder = ($urlMatcherFactoryProvider: UrlMatcherFactory, root: () => StateObject) =>\n  function urlBuilder(stateObject: StateObject) {\n    let stateDec: StateDeclaration = stateObject.self;\n\n    // For future states, i.e., states whose name ends with `.**`,\n    // match anything that starts with the url prefix\n    if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n      const newStateDec: StateDeclaration = {};\n      copy(stateDec, newStateDec);\n      newStateDec.url += '{remainder:any}'; // match any path (.*)\n      stateDec = newStateDec;\n    }\n\n    const parent = stateObject.parent;\n    const parsed = parseUrl(stateDec.url);\n    const url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, { state: stateDec });\n\n    if (!url) return null;\n    if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error(`Invalid url '${url}' in state '${stateObject}'`);\n    return parsed && parsed.root ? url : ((parent && parent.navigable) || root()).url.append(<UrlMatcher>url);\n  };\n\nconst getNavigableBuilder = (isRoot: (state: StateObject) => boolean) =>\n  function navigableBuilder(state: StateObject) {\n    return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;\n  };\n\nconst getParamsBuilder = (paramFactory: ParamFactory) =>\n  function paramsBuilder(state: StateObject): { [key: string]: Param } {\n    const makeConfigParam = (config: ParamDeclaration, id: string) => paramFactory.fromConfig(id, null, state.self);\n    const urlParams: Param[] = (state.url && state.url.parameters({ inherit: false })) || [];\n    const nonUrlParams: Param[] = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n    return urlParams\n      .concat(nonUrlParams)\n      .map((p) => [p.id, p])\n      .reduce(applyPairs, {});\n  };\n\nfunction pathBuilder(state: StateObject) {\n  return state.parent ? state.parent.path.concat(state) : /*root*/ [state];\n}\n\nfunction includesBuilder(state: StateObject) {\n  const includes = state.parent ? extend({}, state.parent.includes) : {};\n  includes[state.name] = true;\n  return includes;\n}\n\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nexport function resolvablesBuilder(state: StateObject): Resolvable[] {\n  interface Tuple {\n    token: any;\n    val: any;\n    deps: any[];\n    policy: ResolvePolicy;\n  }\n\n  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n  const objects2Tuples = (resolveObj: Obj, resolvePolicies: { [key: string]: ResolvePolicy }) =>\n    Object.keys(resolveObj || {}).map((token) => ({\n      token,\n      val: resolveObj[token],\n      deps: undefined,\n      policy: resolvePolicies[token],\n    }));\n\n  /** fetch DI annotations from a function or ng1-style array */\n  const annotate = (fn: Function) => {\n    const $injector = services.$injector;\n    // ng1 doesn't have an $injector until runtime.\n    // If the $injector doesn't exist, use \"deferred\" literal as a\n    // marker indicating they should be annotated when runtime starts\n    return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || <any>'deferred';\n  };\n\n  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n  const isResolveLiteral = (obj: any) => !!(obj.token && obj.resolveFn);\n\n  /** true if the object looks like a provide literal, or a ng2 Provider */\n  const isLikeNg2Provider = (obj: any) =>\n    !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));\n\n  /** true if the object looks like a tuple from obj2Tuples */\n  const isTupleFromObj = (obj: any) =>\n    !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));\n\n  /** extracts the token from a Provider or provide literal */\n  const getToken = (p: any) => p.provide || p.token;\n\n  // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable\n  const literal2Resolvable = pattern([\n    [prop('resolveFn'), (p) => new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy)],\n    [prop('useFactory'), (p) => new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy)],\n    [prop('useClass'), (p) => new Resolvable(getToken(p), () => new (<any>p.useClass)(), [], p.policy)],\n    [prop('useValue'), (p) => new Resolvable(getToken(p), () => p.useValue, [], p.policy, p.useValue)],\n    [prop('useExisting'), (p) => new Resolvable(getToken(p), identity, [p.useExisting], p.policy)],\n  ]);\n\n  // prettier-ignore\n  const tuple2Resolvable = pattern([\n    [pipe(prop('val'), isString),   (tuple: Tuple) => new Resolvable(tuple.token, identity, [tuple.val], tuple.policy)],\n    [pipe(prop('val'), isArray),    (tuple: Tuple) => new Resolvable(tuple.token, tail(<any[]>tuple.val), tuple.val.slice(0, -1), tuple.policy)],\n    [pipe(prop('val'), isFunction), (tuple: Tuple) => new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy)],\n  ]);\n\n  // prettier-ignore\n  const item2Resolvable = <(obj: any) => Resolvable>pattern([\n    [is(Resolvable), (r: Resolvable) => r],\n    [isResolveLiteral, literal2Resolvable],\n    [isLikeNg2Provider, literal2Resolvable],\n    [isTupleFromObj, tuple2Resolvable],\n    [val(true), (obj: any) => { throw new Error('Invalid resolve value: ' + stringify(obj)); }, ],\n  ]);\n\n  // If resolveBlock is already an array, use it as-is.\n  // Otherwise, assume it's an object and convert to an Array of tuples\n  const decl = state.resolve;\n  const items: any[] = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n  return items.map(item2Resolvable);\n}\n\n/**\n * A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nexport class StateBuilder {\n  /** An object that contains all the BuilderFunctions registered, key'd by the name of the State property they build */\n  private builders: Builders;\n\n  constructor(private matcher: StateMatcher, urlMatcherFactory: UrlMatcherFactory) {\n    const self = this;\n\n    const root = () => matcher.find('');\n    const isRoot = (state: StateObject) => state.name === '';\n\n    function parentBuilder(state: StateObject) {\n      if (isRoot(state)) return null;\n      return matcher.find(self.parentName(state)) || root();\n    }\n\n    this.builders = {\n      name: [nameBuilder],\n      self: [selfBuilder],\n      parent: [parentBuilder],\n      data: [dataBuilder],\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: [getUrlBuilder(urlMatcherFactory, root)],\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: [getNavigableBuilder(isRoot)],\n      params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n      // Each framework-specific ui-router implementation should define its own `views` builder\n      // e.g., src/ng1/statebuilders/views.ts\n      views: [],\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: [pathBuilder],\n      // Speed up $state.includes() as it's used a lot\n      includes: [includesBuilder],\n      resolvables: [resolvablesBuilder],\n    };\n  }\n\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param property The name of the State property being registered for.\n   * @param fn The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n  builder(property: string, fn: BuilderFunction): Function;\n  /**\n   * Gets the registered builder functions for a given property of [[StateObject]].\n   *\n   * @param property The name of the State property being registered for.\n   * @returns the registered builder(s).\n   *          note: for backwards compatibility, this may be a single builder or an array of builders\n   */\n  builder(property: string): BuilderFunction | BuilderFunction[];\n  builder(name: string, fn?: BuilderFunction): any {\n    const builders = this.builders;\n    const array = builders[name] || [];\n    // Backwards compat: if only one builder exists, return it, else return whole arary.\n    if (isString(name) && !isDefined(fn)) return array.length > 1 ? array : array[0];\n    if (!isString(name) || !isFunction(fn)) return;\n\n    builders[name] = array;\n    builders[name].push(fn);\n    return () => builders[name].splice(builders[name].indexOf(fn, 1)) && null;\n  }\n\n  /**\n   * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n   * properties and API built.\n   *\n   * @param state an uninitialized State object\n   * @returns the built State object\n   */\n  build(state: StateObject): StateObject {\n    const { matcher, builders } = this;\n    const parent = this.parentName(state);\n\n    if (parent && !matcher.find(parent, undefined, false)) {\n      return null;\n    }\n\n    for (const key in builders) {\n      if (!builders.hasOwnProperty(key)) continue;\n      const chain = builders[key].reduce(\n        (parentFn: BuilderFunction, step: BuilderFunction) => (_state) => step(_state, parentFn),\n        noop\n      );\n      state[key] = chain(state);\n    }\n    return state;\n  }\n\n  parentName(state: StateObject) {\n    // name = 'foo.bar.baz.**'\n    const name = state.name || '';\n    // segments = ['foo', 'bar', 'baz', '.**']\n    const segments = name.split('.');\n    // segments = ['foo', 'bar', 'baz']\n    const lastSegment = segments.pop();\n    // segments = ['foo', 'bar'] (ignore .** segment for future states)\n    if (lastSegment === '**') segments.pop();\n\n    if (segments.length) {\n      if (state.parent) {\n        throw new Error(`States that specify the 'parent:' property should not have a '.' in their name (${name})`);\n      }\n\n      // 'foo.bar'\n      return segments.join('.');\n    }\n\n    if (!state.parent) return '';\n    return isString(state.parent) ? state.parent : state.parent.name;\n  }\n\n  name(state: StateObject) {\n    const name = state.name;\n    if (name.indexOf('.') !== -1 || !state.parent) return name;\n\n    const parentName = isString(state.parent) ? state.parent : state.parent.name;\n    return parentName ? parentName + '.' + name : name;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}