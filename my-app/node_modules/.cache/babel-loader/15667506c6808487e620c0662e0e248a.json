{"ast":null,"code":"import { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport { isObject, isUndefined } from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { TransitionHookPhase } from './interface'; // has or is using\n\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathUtils } from '../path/pathUtils';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { Rejection } from './rejectFactory';\nimport { flattenR, uniqR } from '../common';\n/** @internal */\n\nvar stateSelf = prop('self');\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\n\nvar Transition =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internal\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   * @internal\n   */\n  function Transition(fromPath, targetState, router) {\n    var _this = this;\n    /** @internal */\n\n\n    this._deferred = services.$q.defer();\n    /**\n     * This promise is resolved or rejected based on the outcome of the Transition.\n     *\n     * When the transition is successful, the promise is resolved\n     * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n     */\n\n    this.promise = this._deferred.promise;\n    /** @internal Holds the hook registration functions such as those passed to Transition.onStart() */\n\n    this._registeredHooks = {};\n    /** @internal */\n\n    this._hookBuilder = new HookBuilder(this);\n    /** Checks if this transition is currently active/running. */\n\n    this.isActive = function () {\n      return _this.router.globals.transition === _this;\n    };\n\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    } // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\n\n    this._options = extend({\n      current: val(this)\n    }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    var toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    var onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n\n    TransitionHook.invokeHooks(onCreateHooks, function () {\n      return null;\n    });\n    this.applyViewConfigs(router);\n  }\n  /** @internal */\n\n\n  Transition.prototype.onBefore = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onStart = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onExit = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onRetain = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onEnter = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onFinish = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onSuccess = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onError = function (criteria, callback, options) {\n    return;\n  };\n  /** @internal\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n\n\n  Transition.prototype.createTransitionHookRegFns = function () {\n    var _this = this;\n\n    this.router.transitionService._pluginapi._getEvents().filter(function (type) {\n      return type.hookPhase !== TransitionHookPhase.CREATE;\n    }).forEach(function (type) {\n      return makeEvent(_this, _this.router.transitionService, type);\n    });\n  };\n  /** @internal */\n\n\n  Transition.prototype.getHooks = function (hookName) {\n    return this._registeredHooks[hookName];\n  };\n\n  Transition.prototype.applyViewConfigs = function (router) {\n    var enteringStates = this._treeChanges.entering.map(function (node) {\n      return node.state;\n    });\n\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  };\n  /**\n   * @internal\n   * @returns the internal from [State] object\n   */\n\n\n  Transition.prototype.$from = function () {\n    return tail(this._treeChanges.from).state;\n  };\n  /**\n   * @internal\n   * @returns the internal to [State] object\n   */\n\n\n  Transition.prototype.$to = function () {\n    return tail(this._treeChanges.to).state;\n  };\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n\n\n  Transition.prototype.from = function () {\n    return this.$from().self;\n  };\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n\n\n  Transition.prototype.to = function () {\n    return this.$to().self;\n  };\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n\n\n  Transition.prototype.targetState = function () {\n    return this._targetState;\n  };\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n\n\n  Transition.prototype.is = function (compare) {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({\n        to: compare.$to().name,\n        from: compare.$from().name\n      });\n    }\n\n    return !(compare.to && !matchState(this.$to(), compare.to, this) || compare.from && !matchState(this.$from(), compare.from, this));\n  };\n\n  Transition.prototype.params = function (pathname) {\n    if (pathname === void 0) {\n      pathname = 'to';\n    }\n\n    return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));\n  };\n\n  Transition.prototype.paramsChanged = function () {\n    var fromParams = this.params('from');\n    var toParams = this.params('to'); // All the parameters declared on both the \"to\" and \"from\" paths\n\n    var allParamDescriptors = [].concat(this._treeChanges.to).concat(this._treeChanges.from).map(function (pathNode) {\n      return pathNode.paramSchema;\n    }).reduce(flattenR, []).reduce(uniqR, []);\n    var changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);\n    return changedParamDescriptors.reduce(function (changedValues, descriptor) {\n      changedValues[descriptor.id] = toParams[descriptor.id];\n      return changedValues;\n    }, {});\n  };\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `myResolve` resolve\n   *   // even though `foo.bar` also has a `myResolve` resolve\n   *   var fooData = trans.injector('foo').get('myResolve');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `myResolve` from the state being exited\n   *   var fooData = trans.injector(null, 'from').get('myResolve');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n\n\n  Transition.prototype.injector = function (state, pathName) {\n    if (pathName === void 0) {\n      pathName = 'to';\n    }\n\n    var path = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, function (node) {\n      return node.state === state || node.state.name === state;\n    });\n    return new ResolveContext(path).injector();\n  };\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n\n\n  Transition.prototype.getResolveTokens = function (pathname) {\n    if (pathname === void 0) {\n      pathname = 'to';\n    }\n\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  };\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n\n\n  Transition.prototype.addResolvable = function (resolvable, state) {\n    if (state === void 0) {\n      state = '';\n    }\n\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n    var stateName = typeof state === 'string' ? state : state.name;\n    var topath = this._treeChanges.to;\n    var targetNode = find(topath, function (node) {\n      return node.state.name === stateName;\n    });\n    var resolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable], targetNode.state);\n  };\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n\n\n  Transition.prototype.redirectedFrom = function () {\n    return this._options.redirectedFrom || null;\n  };\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n\n\n  Transition.prototype.originalTransition = function () {\n    var rf = this.redirectedFrom();\n    return rf && rf.originalTransition() || this;\n  };\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n\n\n  Transition.prototype.options = function () {\n    return this._options;\n  };\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n\n\n  Transition.prototype.entering = function () {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  };\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n\n\n  Transition.prototype.exiting = function () {\n    return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n  };\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n\n\n  Transition.prototype.retained = function () {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  };\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n\n\n  Transition.prototype.views = function (pathname, state) {\n    if (pathname === void 0) {\n      pathname = 'entering';\n    }\n\n    var path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path.map(prop('views')).filter(identity).reduce(unnestR, []);\n  };\n\n  Transition.prototype.treeChanges = function (pathname) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  };\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internal\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n\n\n  Transition.prototype.redirect = function (targetState) {\n    var redirects = 1,\n        trans = this; // tslint:disable-next-line:no-conditional-assignment\n\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(\"Too many consecutive Transition redirects (20+)\");\n    }\n\n    var redirectOpts = {\n      redirectedFrom: this,\n      source: 'redirect'\n    }; // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n    var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    var originalEnteringNodes = this._treeChanges.entering;\n    var redirectEnteringNodes = newTransition._treeChanges.entering; // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    var nodeIsReloading = function (reloadState) {\n      return function (node) {\n        return reloadState && node.state.includes[reloadState.name];\n      };\n    }; // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\n\n    var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState))); // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\n    matchingEnteringNodes.forEach(function (node, idx) {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n    return newTransition;\n  };\n  /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\n\n  Transition.prototype._changedParams = function () {\n    var tc = this._treeChanges;\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n\n    if (this._options.reload) return undefined; // If any states are exiting or entering\n\n    if (tc.exiting.length || tc.entering.length) return undefined; // If to/from path lengths differ\n\n    if (tc.to.length !== tc.from.length) return undefined; // If the to/from paths are different\n\n    var pathsDiffer = arrayTuples(tc.to, tc.from).map(function (tuple) {\n      return tuple[0].state !== tuple[1].state;\n    }).reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined; // Find any parameter values that differ\n\n    var nodeSchemas = tc.to.map(function (node) {\n      return node.paramSchema;\n    });\n\n    var _a = [tc.to, tc.from].map(function (path) {\n      return path.map(function (x) {\n        return x.paramValues;\n      });\n    }),\n        toValues = _a[0],\n        fromValues = _a[1];\n\n    var tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n    return tuples.map(function (_a) {\n      var schema = _a[0],\n          toVals = _a[1],\n          fromVals = _a[2];\n      return Param.changed(schema, toVals, fromVals);\n    }).reduce(unnestR, []);\n  };\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n\n\n  Transition.prototype.dynamic = function () {\n    var changes = this._changedParams();\n\n    return !changes ? false : changes.map(function (x) {\n      return x.dynamic;\n    }).reduce(anyTrueR, false);\n  };\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n\n\n  Transition.prototype.ignored = function () {\n    return !!this._ignoredReason();\n  };\n  /** @internal */\n\n\n  Transition.prototype._ignoredReason = function () {\n    var pending = this.router.globals.transition;\n    var reloadState = this._options.reloadState;\n\n    var same = function (pathA, pathB) {\n      if (pathA.length !== pathB.length) return false;\n      var matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter(function (node) {\n        return !reloadState || !node.state.includes[reloadState.name];\n      }).length;\n    };\n\n    var newTC = this.treeChanges();\n    var pendTC = pending && pending.treeChanges();\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return 'SameAsPending';\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return 'SameAsCurrent';\n  };\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internal\n   *\n   * @returns a promise for a successful transition.\n   */\n\n\n  Transition.prototype.run = function () {\n    var _this = this;\n\n    var runAllHooks = TransitionHook.runAllHooks; // Gets transition hooks array for the given phase\n\n    var getHooksFor = function (phase) {\n      return _this._hookBuilder.buildHooksForPhase(phase);\n    }; // When the chain is complete, then resolve or reject the deferred\n\n\n    var transitionSuccess = function () {\n      trace.traceSuccess(_this.$to(), _this);\n      _this.success = true;\n\n      _this._deferred.resolve(_this.to());\n\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    var transitionError = function (reason) {\n      trace.traceError(reason, _this);\n      _this.success = false;\n\n      _this._deferred.reject(reason);\n\n      _this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    var runTransition = function () {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      var allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n\n      var done = function () {\n        return services.$q.when(undefined);\n      };\n\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    var startTransition = function () {\n      var globals = _this.router.globals;\n      globals.lastStartedTransitionId = _this.$id;\n      globals.transition = _this;\n      globals.transitionHistory.enqueue(_this);\n      trace.traceTransitionStart(_this);\n      return services.$q.when(undefined);\n    };\n\n    var allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition).then(runTransition).then(transitionSuccess, transitionError);\n    return this.promise;\n  };\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n\n\n  Transition.prototype.valid = function () {\n    return !this.error() || this.success !== undefined;\n  };\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n\n\n  Transition.prototype.abort = function () {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  };\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n\n\n  Transition.prototype.error = function () {\n    var state = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(\"Cannot transition to abstract state '\" + state.name + \"'\");\n    }\n\n    var paramDefs = state.parameters();\n    var values = this.params();\n    var invalidParams = paramDefs.filter(function (param) {\n      return !param.validates(values[param.id]);\n    });\n\n    if (invalidParams.length) {\n      var invalidValues = invalidParams.map(function (param) {\n        return \"[\" + param.id + \":\" + stringify(values[param.id]) + \"]\";\n      }).join(', ');\n      var detail = \"The following parameter values are not valid for state '\" + state.name + \"': \" + invalidValues;\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n  };\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n\n\n  Transition.prototype.toString = function () {\n    var fromStateOrName = this.from();\n    var toStateOrName = this.to();\n\n    var avoidEmptyHash = function (params) {\n      return params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);\n    }; // (X) means the to state is invalid.\n\n\n    var id = this.$id,\n        from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n        fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n        toValid = this.valid() ? '' : '(X) ',\n        to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n        toParams = stringify(avoidEmptyHash(this.params()));\n    return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n  };\n  /** @internal */\n\n\n  Transition.diToken = Transition;\n  return Transition;\n}();\n\nexport { Transition };","map":{"version":3,"mappings":"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","names":["trace","services","stringify","map","find","extend","mergeR","tail","omit","arrayTuples","unnestR","identity","anyTrueR","isObject","isUndefined","prop","propEq","val","not","is","TransitionHookPhase","TransitionHook","matchState","makeEvent","HookBuilder","PathUtils","Param","Resolvable","ResolveContext","Rejection","flattenR","uniqR","stateSelf","fromPath","targetState","router","$q","defer","_deferred","promise","globals","transition","_this","_targetState","valid","Error","error","_options","current","options","$id","transitionService","_transitionCount","toPath","buildToPath","_treeChanges","treeChanges","reloadState","createTransitionHookRegFns","onCreateHooks","_hookBuilder","buildHooksForPhase","CREATE","invokeHooks","applyViewConfigs","Transition","criteria","callback","_pluginapi","_getEvents","filter","type","hookPhase","forEach","hookName","_registeredHooks","enteringStates","entering","node","state","$view","to","from","$from","self","$to","compare","name","pathname","Object","freeze","reduce","fromParams","params","toParams","allParamDescriptors","concat","pathNode","paramSchema","changedParamDescriptors","changed","changedValues","descriptor","id","pathName","path","subPath","injector","getTokens","resolvable","stateName","topath","targetNode","resolveContext","addResolvables","redirectedFrom","rf","originalTransition","exiting","reverse","retained","redirects","trans","redirectOpts","source","location","newOptions","withOptions","newTransition","create","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","includes","matchingEnteringNodes","matching","nonDynamicParams","idx","resolvables","tc","reload","undefined","length","pathsDiffer","tuple","nodeSchemas","x","paramValues","toValues","fromValues","tuples","_a","schema","toVals","fromVals","changes","_changedParams","dynamic","_ignoredReason","pending","same","pathA","pathB","newTC","pendTC","runAllHooks","getHooksFor","phase","transitionSuccess","traceSuccess","success","resolve","SUCCESS","transitionError","reason","traceError","reject","_error","ERROR","runTransition","allRunHooks","RUN","done","when","startTransition","lastStartedTransitionId","transitionHistory","enqueue","traceTransitionStart","allBeforeHooks","BEFORE","then","_aborted","abstract","invalid","paramDefs","parameters","values","invalidParams","param","validates","invalidValues","join","detail","fromStateOrName","toStateOrName","avoidEmptyHash","toValid"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\transition\\@uirouter\\core\\transition\\transition.ts"],"sourcesContent":["import { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport { isObject, isUndefined } from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { StateDeclaration, StateOrName } from '../state/interface';\nimport {\n  TransitionOptions,\n  TreeChanges,\n  IHookRegistry,\n  TransitionHookPhase,\n  RegisteredHooks,\n  HookRegOptions,\n  HookMatchCriteria,\n  TransitionStateHookFn,\n  TransitionHookFn,\n} from './interface'; // has or is using\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent, RegisteredHook } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathNode } from '../path/pathNode';\nimport { PathUtils } from '../path/pathUtils';\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { UIRouter } from '../router';\nimport { UIInjector } from '../interface';\nimport { RawParams } from '../params/interface';\nimport { ResolvableLiteral } from '../resolve/interface';\nimport { Rejection } from './rejectFactory';\nimport { applyPairs, flattenR, uniqR } from '../common';\n\n/** @internal */\nconst stateSelf: (_state: StateObject) => StateDeclaration = prop('self');\n\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nexport class Transition implements IHookRegistry {\n  /** @internal */\n  static diToken = Transition;\n\n  /**\n   * A unique identifier for the transition.\n   *\n   * This is an auto incrementing integer, starting from `0`.\n   */\n  $id: number;\n\n  /**\n   * A reference to the [[UIRouter]] instance\n   *\n   * This reference can be used to access the router services, such as the [[StateService]]\n   */\n  router: UIRouter;\n\n  /** @internal */\n  private _deferred = services.$q.defer();\n  /**\n   * This promise is resolved or rejected based on the outcome of the Transition.\n   *\n   * When the transition is successful, the promise is resolved\n   * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n   */\n  promise: Promise<any> = this._deferred.promise;\n  /**\n   * A boolean which indicates if the transition was successful\n   *\n   * After a successful transition, this value is set to true.\n   * After an unsuccessful transition, this value is set to false.\n   *\n   * The value will be undefined if the transition is not complete\n   */\n  success: boolean;\n  /** @internal */\n  _aborted: boolean;\n  /** @internal */\n  private _error: Rejection;\n\n  /** @internal Holds the hook registration functions such as those passed to Transition.onStart() */\n  _registeredHooks: RegisteredHooks = {};\n\n  /** @internal */\n  private _options: TransitionOptions;\n  /** @internal */\n  private _treeChanges: TreeChanges;\n  /** @internal */\n  private _targetState: TargetState;\n  /** @internal */\n  private _hookBuilder = new HookBuilder(this);\n\n  /** @internal */\n  onBefore(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onStart(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onExit(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onRetain(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onEnter(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onFinish(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onSuccess(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onError(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n\n  /** @internal\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n  private createTransitionHookRegFns() {\n    this.router.transitionService._pluginapi\n      ._getEvents()\n      .filter((type) => type.hookPhase !== TransitionHookPhase.CREATE)\n      .forEach((type) => makeEvent(this, this.router.transitionService, type));\n  }\n\n  /** @internal */\n  getHooks(hookName: string): RegisteredHook[] {\n    return this._registeredHooks[hookName];\n  }\n\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internal\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   * @internal\n   */\n  constructor(fromPath: PathNode[], targetState: TargetState, router: UIRouter) {\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    }\n\n    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n    this._options = extend({ current: val(this) }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    const toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    const onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n    TransitionHook.invokeHooks(onCreateHooks, () => null);\n\n    this.applyViewConfigs(router);\n  }\n\n  private applyViewConfigs(router: UIRouter) {\n    const enteringStates = this._treeChanges.entering.map((node) => node.state);\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  }\n\n  /**\n   * @internal\n   * @returns the internal from [State] object\n   */\n  $from() {\n    return tail(this._treeChanges.from).state;\n  }\n\n  /**\n   * @internal\n   * @returns the internal to [State] object\n   */\n  $to() {\n    return tail(this._treeChanges.to).state;\n  }\n\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n  from(): StateDeclaration {\n    return this.$from().self;\n  }\n\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n  to(): StateDeclaration {\n    return this.$to().self;\n  }\n\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n  targetState() {\n    return this._targetState;\n  }\n\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n  is(compare: Transition | { to?: any; from?: any }): boolean {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({ to: compare.$to().name, from: compare.$from().name });\n    }\n    return !(\n      (compare.to && !matchState(this.$to(), compare.to, this)) ||\n      (compare.from && !matchState(this.$from(), compare.from, this))\n    );\n  }\n\n  /**\n   * Gets transition parameter values\n   *\n   * Returns the parameter values for a transition as key/value pairs.\n   * This object is immutable.\n   *\n   * By default, returns the new parameter values (for the \"to state\").\n   *\n   * #### Example:\n   * ```js\n   * var toParams = transition.params();\n   * ```\n   *\n   * To return the previous parameter values,  supply `'from'` as the `pathname` argument.\n   *\n   * #### Example:\n   * ```js\n   * var fromParams = transition.params('from');\n   * ```\n   *\n   * @param pathname the name of the treeChanges path to get parameter values for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   *\n   * @returns transition parameter values for the desired path.\n   */\n  params(pathname?: string): { [paramName: string]: any };\n  params<T>(pathname?: string): T;\n  params(pathname = 'to') {\n    return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));\n  }\n\n  /**\n   * Gets the new values of any parameters that changed during this transition.\n   *\n   * Returns any parameter values that have changed during a transition, as key/value pairs.\n   *\n   * - Any parameter values that have changed will be present on the returned object reflecting the new value.\n   * - Any parameters that *not* have changed will not be present on the returned object.\n   * - Any new parameters that weren't present in the \"from\" state, but are now present in the \"to\" state will be present on the returned object.\n   * - Any previous parameters that are no longer present (because the \"to\" state doesn't have them) will be included with a value of `undefined`.\n   *\n   * The returned object is immutable.\n   *\n   * #### Examples:\n   *\n   * Given:\n   * ```js\n   * var stateA = { name: 'stateA', url: '/stateA/:param1/param2' }\n   * var stateB = { name: 'stateB', url: '/stateB/:param3' }\n   * var stateC = { name: 'stateB.nest', url: '/nest/:param4' }\n   * ```\n   *\n   * #### Example 1\n   *\n   * From `/stateA/abc/def` to `/stateA/abc/xyz`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param2: 'xyz' }\n   * ```\n   *\n   * The value of `param2` changed to `xyz`.\n   * The value of `param1` stayed the same so its value is not present.\n   *\n   * #### Example 2\n   *\n   * From `/stateA/abc/def` to `/stateB/123`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param1: undefined, param2: undefined, param3: '123' }\n   * ```\n   *\n   * The value `param3` is present because it is a new param.\n   * Both `param1` and `param2` are no longer present so their value is undefined.\n   *\n   * #### Example 3\n   *\n   * From `/stateB/123` to `/stateB/123/nest/456`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param4: '456' }\n   * ```\n   *\n   * The value `param4` is present because it is a new param.\n   * The value of `param3` did not change, so its value is not present.\n   *\n   * @returns an immutable object with changed parameter keys/values.\n   */\n  paramsChanged(): { [paramName: string]: any };\n  paramsChanged<T>(): T;\n  paramsChanged() {\n    const fromParams = this.params('from');\n    const toParams = this.params('to');\n\n    // All the parameters declared on both the \"to\" and \"from\" paths\n    const allParamDescriptors: Param[] = []\n      .concat(this._treeChanges.to)\n      .concat(this._treeChanges.from)\n      .map((pathNode) => pathNode.paramSchema)\n      .reduce(flattenR, [])\n      .reduce(uniqR, []);\n\n    const changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);\n\n    return changedParamDescriptors.reduce((changedValues, descriptor) => {\n      changedValues[descriptor.id] = toParams[descriptor.id];\n      return changedValues;\n    }, {});\n  }\n\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `myResolve` resolve\n   *   // even though `foo.bar` also has a `myResolve` resolve\n   *   var fooData = trans.injector('foo').get('myResolve');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `myResolve` from the state being exited\n   *   var fooData = trans.injector(null, 'from').get('myResolve');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n  injector(state?: StateOrName, pathName = 'to'): UIInjector {\n    let path: PathNode[] = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, (node) => node.state === state || node.state.name === state);\n    return new ResolveContext(path).injector();\n  }\n\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n  getResolveTokens(pathname = 'to'): any[] {\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  }\n\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n  addResolvable(resolvable: Resolvable | ResolvableLiteral, state: StateOrName = ''): void {\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n\n    const stateName: string = typeof state === 'string' ? state : state.name;\n    const topath = this._treeChanges.to;\n    const targetNode = find(topath, (node) => node.state.name === stateName);\n    const resolveContext: ResolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable as Resolvable], targetNode.state);\n  }\n\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n  redirectedFrom(): Transition {\n    return this._options.redirectedFrom || null;\n  }\n\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n  originalTransition(): Transition {\n    const rf = this.redirectedFrom();\n    return (rf && rf.originalTransition()) || this;\n  }\n\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n  options(): TransitionOptions {\n    return this._options;\n  }\n\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n  entering(): StateDeclaration[] {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n  exiting(): StateDeclaration[] {\n    return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n  }\n\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n  retained(): StateDeclaration[] {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n  views(pathname = 'entering', state?: StateObject): ViewConfig[] {\n    let path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path.map(prop('views')).filter(identity).reduce(unnestR, []);\n  }\n\n  /**\n   * Return the transition's tree changes\n   *\n   * A transition goes from one state/parameters to another state/parameters.\n   * During a transition, states are entered and/or exited.\n   *\n   * This function returns various branches (paths) which represent the changes to the\n   * active state tree that are caused by the transition.\n   *\n   * @param pathname The name of the tree changes path to get:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   */\n  treeChanges(pathname: string): PathNode[];\n  treeChanges(): TreeChanges;\n  treeChanges(pathname?: string) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  }\n\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internal\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n  redirect(targetState: TargetState): Transition {\n    let redirects = 1,\n      trans: Transition = this;\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(`Too many consecutive Transition redirects (20+)`);\n    }\n\n    const redirectOpts: TransitionOptions = { redirectedFrom: this, source: 'redirect' };\n    // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    const newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n\n    const newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    const originalEnteringNodes = this._treeChanges.entering;\n    const redirectEnteringNodes = newTransition._treeChanges.entering;\n\n    // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    const nodeIsReloading = (reloadState: StateObject) => (node: PathNode) => {\n      return reloadState && node.state.includes[reloadState.name];\n    };\n\n    // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n    const matchingEnteringNodes: PathNode[] = PathUtils.matching(\n      redirectEnteringNodes,\n      originalEnteringNodes,\n      PathUtils.nonDynamicParams\n    ).filter(not(nodeIsReloading(targetState.options().reloadState)));\n\n    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n    matchingEnteringNodes.forEach((node, idx) => {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n\n    return newTransition;\n  }\n\n  /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n  private _changedParams(): Param[] {\n    const tc = this._treeChanges;\n\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n    if (this._options.reload) return undefined;\n    // If any states are exiting or entering\n    if (tc.exiting.length || tc.entering.length) return undefined;\n    // If to/from path lengths differ\n    if (tc.to.length !== tc.from.length) return undefined;\n    // If the to/from paths are different\n    const pathsDiffer: boolean = arrayTuples(tc.to, tc.from)\n      .map((tuple) => tuple[0].state !== tuple[1].state)\n      .reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined;\n\n    // Find any parameter values that differ\n    const nodeSchemas: Param[][] = tc.to.map((node: PathNode) => node.paramSchema);\n    const [toValues, fromValues] = [tc.to, tc.from].map((path) => path.map((x) => x.paramValues));\n    const tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\n    return tuples.map(([schema, toVals, fromVals]) => Param.changed(schema, toVals, fromVals)).reduce(unnestR, []);\n  }\n\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n  dynamic(): boolean {\n    const changes = this._changedParams();\n    return !changes ? false : changes.map((x) => x.dynamic).reduce(anyTrueR, false);\n  }\n\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n  ignored(): boolean {\n    return !!this._ignoredReason();\n  }\n\n  /** @internal */\n  _ignoredReason(): 'SameAsCurrent' | 'SameAsPending' | undefined {\n    const pending = this.router.globals.transition;\n    const reloadState = this._options.reloadState;\n\n    const same = (pathA, pathB) => {\n      if (pathA.length !== pathB.length) return false;\n      const matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter((node) => !reloadState || !node.state.includes[reloadState.name]).length;\n    };\n\n    const newTC = this.treeChanges();\n    const pendTC = pending && pending.treeChanges();\n\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return 'SameAsPending';\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return 'SameAsCurrent';\n  }\n\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internal\n   *\n   * @returns a promise for a successful transition.\n   */\n  run(): Promise<any> {\n    const runAllHooks = TransitionHook.runAllHooks;\n\n    // Gets transition hooks array for the given phase\n    const getHooksFor = (phase: TransitionHookPhase) => this._hookBuilder.buildHooksForPhase(phase);\n\n    // When the chain is complete, then resolve or reject the deferred\n    const transitionSuccess = () => {\n      trace.traceSuccess(this.$to(), this);\n      this.success = true;\n      this._deferred.resolve(this.to());\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    const transitionError = (reason: Rejection) => {\n      trace.traceError(reason, this);\n      this.success = false;\n      this._deferred.reject(reason);\n      this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    const runTransition = () => {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      const allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n      const done = () => services.$q.when(undefined);\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    const startTransition = () => {\n      const globals = this.router.globals;\n\n      globals.lastStartedTransitionId = this.$id;\n      globals.transition = this;\n      globals.transitionHistory.enqueue(this);\n\n      trace.traceTransitionStart(this);\n\n      return services.$q.when(undefined);\n    };\n\n    const allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n      .then(runTransition)\n      .then(transitionSuccess, transitionError);\n\n    return this.promise;\n  }\n\n  /** Checks if this transition is currently active/running. */\n  isActive = () => this.router.globals.transition === this;\n\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n  valid() {\n    return !this.error() || this.success !== undefined;\n  }\n\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n  abort() {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  }\n\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n  error(): Rejection {\n    const state: StateObject = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(`Cannot transition to abstract state '${state.name}'`);\n    }\n\n    const paramDefs = state.parameters();\n    const values = this.params();\n    const invalidParams = paramDefs.filter((param) => !param.validates(values[param.id]));\n\n    if (invalidParams.length) {\n      const invalidValues = invalidParams.map((param) => `[${param.id}:${stringify(values[param.id])}]`).join(', ');\n      const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n  }\n\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n  toString() {\n    const fromStateOrName = this.from();\n    const toStateOrName = this.to();\n\n    const avoidEmptyHash = (params: RawParams) =>\n      params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);\n\n    // (X) means the to state is invalid.\n    const id = this.$id,\n      from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n      fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n      toValid = this.valid() ? '' : '(X) ',\n      to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n      toParams = stringify(avoidEmptyHash(this.params()));\n\n    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}