{"ast":null,"code":"import { extend, assertPredicate, unnestR, identity } from '../common/common';\nimport { isArray } from '../common/predicates';\nimport { TransitionHookPhase, TransitionHookScope } from './interface';\nimport { TransitionHook } from './transitionHook';\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n */\n\nvar HookBuilder =\n/** @class */\nfunction () {\n  function HookBuilder(transition) {\n    this.transition = transition;\n  }\n\n  HookBuilder.prototype.buildHooksForPhase = function (phase) {\n    var _this = this;\n\n    var $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi._getEvents(phase).map(function (type) {\n      return _this.buildHooks(type);\n    }).reduce(unnestR, []).filter(identity);\n  };\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n\n\n  HookBuilder.prototype.buildHooks = function (hookType) {\n    var transition = this.transition;\n    var treeChanges = transition.treeChanges(); // Find all the matching registered hooks for a given hook type\n\n    var matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);\n    if (!matchingHooks) return [];\n    var baseHookOptions = {\n      transition: transition,\n      current: transition.options().current\n    };\n\n    var makeTransitionHooks = function (hook) {\n      // Fetch the Nodes that caused this hook to match.\n      var matches = hook.matches(treeChanges, transition); // Select the PathNode[] that will be used as TransitionHook context objects\n\n      var matchingNodes = matches[hookType.criteriaMatchPath.name]; // Return an array of HookTuples\n\n      return matchingNodes.map(function (node) {\n        var _options = extend({\n          bind: hook.bind,\n          traceData: {\n            hookType: hookType.name,\n            context: node\n          }\n        }, baseHookOptions);\n\n        var state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n        var transitionHook = new TransitionHook(transition, state, hook, _options);\n        return {\n          hook: hook,\n          node: node,\n          transitionHook: transitionHook\n        };\n      });\n    };\n\n    return matchingHooks.map(makeTransitionHooks).reduce(unnestR, []).sort(tupleSort(hookType.reverseSort)).map(function (tuple) {\n      return tuple.transitionHook;\n    });\n  };\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n\n\n  HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges, transition) {\n    var isCreate = hookType.hookPhase === TransitionHookPhase.CREATE; // Instance and Global hook registries\n\n    var $transitions = this.transition.router.transitionService;\n    var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n    return registries.map(function (reg) {\n      return reg.getHooks(hookType.name);\n    }) // Get named hooks from registries\n    .filter(assertPredicate(isArray, \"broken event named: \" + hookType.name)) // Sanity check\n    .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n    .filter(function (hook) {\n      return hook.matches(treeChanges, transition);\n    }); // Only those satisfying matchCriteria\n  };\n\n  return HookBuilder;\n}();\n\nexport { HookBuilder };\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\n\nfunction tupleSort(reverseDepthSort) {\n  if (reverseDepthSort === void 0) {\n    reverseDepthSort = false;\n  }\n\n  return function nodeDepthThenPriority(l, r) {\n    var factor = reverseDepthSort ? -1 : 1;\n    var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  };\n}","map":{"version":3,"mappings":"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","names":["extend","assertPredicate","unnestR","identity","isArray","TransitionHookPhase","TransitionHookScope","TransitionHook","transition","HookBuilder","phase","$transitions","router","transitionService","_pluginapi","_getEvents","map","type","buildHooks","reduce","filter","hookType","treeChanges","matchingHooks","getMatchingHooks","baseHookOptions","current","options","makeTransitionHooks","hook","matches","matchingNodes","criteriaMatchPath","name","node","_options","bind","traceData","context","state","scope","STATE","self","transitionHook","sort","tupleSort","reverseSort","tuple","isCreate","hookPhase","CREATE","registries","reg","getHooks","reverseDepthSort","nodeDepthThenPriority","l","r","factor","depthDelta","path","length","priority"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\transition\\@uirouter\\core\\transition\\hookBuilder.ts"],"sourcesContent":["import { extend, tail, assertPredicate, unnestR, identity } from '../common/common';\nimport { isArray } from '../common/predicates';\n\nimport {\n  TransitionOptions,\n  TransitionHookOptions,\n  IHookRegistry,\n  TreeChanges,\n  IMatchingNodes,\n  TransitionHookPhase,\n  TransitionHookScope,\n} from './interface';\n\nimport { Transition } from './transition';\nimport { TransitionHook } from './transitionHook';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { TransitionService } from './transitionService';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\n\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n */\nexport class HookBuilder {\n  constructor(private transition: Transition) {}\n\n  buildHooksForPhase(phase: TransitionHookPhase): TransitionHook[] {\n    const $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi\n      ._getEvents(phase)\n      .map((type) => this.buildHooks(type))\n      .reduce(unnestR, [])\n      .filter(identity);\n  }\n\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n  buildHooks(hookType: TransitionEventType): TransitionHook[] {\n    const transition = this.transition;\n    const treeChanges = transition.treeChanges();\n\n    // Find all the matching registered hooks for a given hook type\n    const matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);\n    if (!matchingHooks) return [];\n\n    const baseHookOptions = <TransitionHookOptions>{\n      transition: transition,\n      current: transition.options().current,\n    };\n\n    const makeTransitionHooks = (hook: RegisteredHook) => {\n      // Fetch the Nodes that caused this hook to match.\n      const matches: IMatchingNodes = hook.matches(treeChanges, transition);\n      // Select the PathNode[] that will be used as TransitionHook context objects\n      const matchingNodes: PathNode[] = matches[hookType.criteriaMatchPath.name];\n\n      // Return an array of HookTuples\n      return matchingNodes.map((node) => {\n        const _options = extend(\n          {\n            bind: hook.bind,\n            traceData: { hookType: hookType.name, context: node },\n          },\n          baseHookOptions\n        );\n\n        const state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n        const transitionHook = new TransitionHook(transition, state, hook, _options);\n        return <HookTuple>{ hook, node, transitionHook };\n      });\n    };\n\n    return matchingHooks\n      .map(makeTransitionHooks)\n      .reduce(unnestR, [])\n      .sort(tupleSort(hookType.reverseSort))\n      .map((tuple) => tuple.transitionHook);\n  }\n\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n  public getMatchingHooks(\n    hookType: TransitionEventType,\n    treeChanges: TreeChanges,\n    transition: Transition\n  ): RegisteredHook[] {\n    const isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;\n\n    // Instance and Global hook registries\n    const $transitions = this.transition.router.transitionService;\n    const registries = isCreate ? [$transitions] : [this.transition, $transitions];\n\n    return registries\n      .map((reg: IHookRegistry) => reg.getHooks(hookType.name)) // Get named hooks from registries\n      .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check\n      .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n      .filter((hook) => hook.matches(treeChanges, transition)); // Only those satisfying matchCriteria\n  }\n}\n\ninterface HookTuple {\n  hook: RegisteredHook;\n  node: PathNode;\n  transitionHook: TransitionHook;\n}\n\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort = false) {\n  return function nodeDepthThenPriority(l: HookTuple, r: HookTuple): number {\n    const factor = reverseDepthSort ? -1 : 1;\n    const depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}