{"ast":null,"code":"import { extend, filter, map } from '../common/common';\nimport { isArray, isDefined } from '../common/predicates';\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n */\n\nvar ParamType =\n/** @class */\nfunction () {\n  /**\n   * @param def  A configuration object which contains the custom type definition.  The object's\n   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n   * @returns a new ParamType object\n   */\n  function ParamType(def) {\n    /** @inheritdoc */\n    this.pattern = /.*/;\n    /** @inheritdoc */\n\n    this.inherit = true;\n    extend(this, def);\n  } // consider these four methods to be \"abstract methods\" that should be overridden\n\n  /** @inheritdoc */\n\n\n  ParamType.prototype.is = function (val, key) {\n    return true;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.encode = function (val, key) {\n    return val;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.decode = function (val, key) {\n    return val;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.equals = function (a, b) {\n    // tslint:disable-next-line:triple-equals\n    return a == b;\n  };\n\n  ParamType.prototype.$subPattern = function () {\n    var sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  };\n\n  ParamType.prototype.toString = function () {\n    return \"{ParamType:\" + this.name + \"}\";\n  };\n  /** Given an encoded string, or a decoded object, returns a decoded object */\n\n\n  ParamType.prototype.$normalize = function (val) {\n    return this.is(val) ? val : this.decode(val);\n  };\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   */\n\n\n  ParamType.prototype.$asArray = function (mode, isSearch) {\n    if (!mode) return this;\n    if (mode === 'auto' && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n    return new ArrayType(this, mode);\n  };\n\n  return ParamType;\n}();\n\nexport { ParamType };\n/** Wraps up a `ParamType` object to handle array values. */\n\nfunction ArrayType(type, mode) {\n  var _this = this; // Wrap non-array value as array\n\n\n  function arrayWrap(val) {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  } // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\n\n  function arrayUnwrap(val) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n\n      case 1:\n        return mode === 'auto' ? val[0] : val;\n\n      default:\n        return val;\n    }\n  } // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\n\n  function arrayHandler(callback, allTruthyMode) {\n    return function handleArray(val) {\n      if (isArray(val) && val.length === 0) return val;\n      var arr = arrayWrap(val);\n      var result = map(arr, callback);\n      return allTruthyMode === true ? filter(result, function (x) {\n        return !x;\n      }).length === 0 : arrayUnwrap(result);\n    };\n  } // Wraps type (.equals) functions to operate on each value of an array\n\n\n  function arrayEqualsHandler(callback) {\n    return function handleArray(val1, val2) {\n      var left = arrayWrap(val1),\n          right = arrayWrap(val2);\n      if (left.length !== right.length) return false;\n\n      for (var i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n\n      return true;\n    };\n  }\n\n  ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n    var paramTypeFn = type[name].bind(type);\n    var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n    _this[name] = wrapperFn(paramTypeFn);\n  });\n  extend(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode\n  });\n}","map":{"version":3,"mappings":"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","names":["extend","filter","map","isArray","isDefined","def","ParamType","val","key","a","b","sub","pattern","toString","substr","length","name","is","decode","mode","isSearch","Error","ArrayType","type","arrayWrap","arrayUnwrap","undefined","arrayHandler","callback","allTruthyMode","handleArray","arr","result","x","arrayEqualsHandler","val1","val2","left","right","i","forEach","paramTypeFn","bind","wrapperFn","_this","dynamic","inherit","raw","$arrayMode"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\params\\@uirouter\\core\\params\\paramType.ts"],"sourcesContent":["import { extend, filter, map } from '../common/common';\nimport { isArray, isDefined } from '../common/predicates';\nimport { ParamTypeDefinition } from './interface';\n\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n */\nexport class ParamType implements ParamTypeDefinition {\n  /** @inheritdoc */\n  pattern: RegExp = /.*/;\n  /** The name/id of the parameter type */\n  name: string;\n  /** @inheritdoc */\n  raw: boolean;\n  /** @inheritdoc */\n  dynamic: boolean;\n  /** @inheritdoc */\n  inherit = true;\n\n  /**\n   * @param def  A configuration object which contains the custom type definition.  The object's\n   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n   * @returns a new ParamType object\n   */\n  constructor(def: ParamTypeDefinition) {\n    extend(this, def);\n  }\n\n  // consider these four methods to be \"abstract methods\" that should be overridden\n  /** @inheritdoc */\n  is(val: any, key?: string): boolean {\n    return true;\n  }\n  /** @inheritdoc */\n  encode(val: any, key?: string): string | string[] {\n    return val;\n  }\n  /** @inheritdoc */\n  decode(val: string, key?: string): any {\n    return val;\n  }\n  /** @inheritdoc */\n  equals(a: any, b: any): boolean {\n    // tslint:disable-next-line:triple-equals\n    return a == b;\n  }\n\n  $subPattern() {\n    const sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  }\n\n  toString() {\n    return `{ParamType:${this.name}}`;\n  }\n\n  /** Given an encoded string, or a decoded object, returns a decoded object */\n  $normalize(val: any) {\n    return this.is(val) ? val : this.decode(val);\n  }\n\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   */\n  $asArray(mode: boolean | 'auto', isSearch: boolean) {\n    if (!mode) return this;\n    if (mode === 'auto' && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n    return new (<any>ArrayType)(this, mode);\n  }\n}\n\n/** Wraps up a `ParamType` object to handle array values. */\nfunction ArrayType(type: ParamType, mode: boolean | 'auto') {\n  // Wrap non-array value as array\n  function arrayWrap(val: any): any[] {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  }\n\n  // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n  function arrayUnwrap(val: any) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n      case 1:\n        return mode === 'auto' ? val[0] : val;\n      default:\n        return val;\n    }\n  }\n\n  // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n  function arrayHandler(callback: (x: any) => any, allTruthyMode?: boolean) {\n    return function handleArray(val: any) {\n      if (isArray(val) && val.length === 0) return val;\n      const arr = arrayWrap(val);\n      const result = map(arr, callback);\n      return allTruthyMode === true ? filter(result, (x) => !x).length === 0 : arrayUnwrap(result);\n    };\n  }\n\n  // Wraps type (.equals) functions to operate on each value of an array\n  function arrayEqualsHandler(callback: (l: any, r: any) => boolean) {\n    return function handleArray(val1: any, val2: any) {\n      const left = arrayWrap(val1),\n        right = arrayWrap(val2);\n      if (left.length !== right.length) return false;\n      for (let i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n      return true;\n    };\n  }\n\n  ['encode', 'decode', 'equals', '$normalize'].forEach((name) => {\n    const paramTypeFn = type[name].bind(type);\n    const wrapperFn: Function = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n    this[name] = wrapperFn(paramTypeFn);\n  });\n\n  extend(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}