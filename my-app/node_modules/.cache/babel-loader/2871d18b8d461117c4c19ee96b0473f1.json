{"ast":null,"code":"import { extend, identity } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { trace } from '../common/trace';\nimport { stringify } from '../common/strings';\nimport { isFunction, isObject } from '../common/predicates';\nimport { isNullOrUndefined } from '../common/predicates'; // TODO: explicitly make this user configurable\n\nexport var defaultResolvePolicy = {\n  when: 'LAZY',\n  async: 'WAIT'\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\n\nvar Resolvable =\n/** @class */\nfunction () {\n  function Resolvable(arg1, resolveFn, deps, policy, data) {\n    this.resolved = false;\n    this.promise = undefined;\n\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error('new Resolvable(): token argument is required');\n      if (!isFunction(resolveFn)) throw new Error('new Resolvable(): resolveFn argument must be a function');\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {\n      var literal = arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  Resolvable.prototype.getPolicy = function (state) {\n    var thisPolicy = this.policy || {};\n    var statePolicy = state && state.resolvePolicy || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async\n    };\n  };\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n\n\n  Resolvable.prototype.resolve = function (resolveContext, trans) {\n    var _this = this;\n\n    var $q = services.$q; // Gets all dependencies from ResolveContext and wait for them to be resolved\n\n    var getResolvableDependencies = function () {\n      return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n        return resolvable.get(resolveContext, trans);\n      }));\n    }; // Invokes the resolve function passing the resolved dependencies as arguments\n\n\n    var invokeResolveFn = function (resolvedDeps) {\n      return _this.resolveFn.apply(null, resolvedDeps);\n    };\n\n    var node = resolveContext.findNode(this);\n    var state = node && node.state;\n    var asyncPolicy = this.getPolicy(state).async;\n    var customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity; // After the final value has been resolved, update the state of the Resolvable\n\n    var applyResolvedValue = function (resolvedValue) {\n      _this.data = resolvedValue;\n      _this.resolved = true;\n      _this.resolveFn = null;\n      trace.traceResolvableResolved(_this, trans);\n      return _this.data;\n    }; // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\n\n    return this.promise = $q.when().then(getResolvableDependencies).then(invokeResolveFn).then(customAsyncPolicy).then(applyResolvedValue);\n  };\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n\n\n  Resolvable.prototype.get = function (resolveContext, trans) {\n    return this.promise || this.resolve(resolveContext, trans);\n  };\n\n  Resolvable.prototype.toString = function () {\n    return \"Resolvable(token: \" + stringify(this.token) + \", requires: [\" + this.deps.map(stringify) + \"])\";\n  };\n\n  Resolvable.prototype.clone = function () {\n    return new Resolvable(this);\n  };\n\n  Resolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () {\n      return data;\n    }, null, null, data);\n  };\n\n  return Resolvable;\n}();\n\nexport { Resolvable };","map":{"version":3,"mappings":"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","names":["extend","identity","services","trace","stringify","isFunction","isObject","isNullOrUndefined","defaultResolvePolicy","when","async","arg1","resolveFn","deps","policy","data","undefined","Resolvable","Error","token","resolved","promise","$q","hasOwnProperty","literal","state","thisPolicy","statePolicy","resolvePolicy","resolveContext","trans","getResolvableDependencies","all","getDependencies","_this","map","resolvable","get","invokeResolveFn","resolvedDeps","apply","node","findNode","asyncPolicy","getPolicy","customAsyncPolicy","applyResolvedValue","resolvedValue","traceResolvableResolved","then","resolve"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\resolve\\@uirouter\\core\\resolve\\resolvable.ts"],"sourcesContent":["import { extend, identity } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { trace } from '../common/trace';\nimport { ResolvePolicy, ResolvableLiteral, PolicyAsync } from './interface';\n\nimport { ResolveContext } from './resolveContext';\nimport { stringify } from '../common/strings';\nimport { isFunction, isObject } from '../common/predicates';\nimport { Transition } from '../transition/transition';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { isNullOrUndefined } from '../common/predicates';\n\n// TODO: explicitly make this user configurable\nexport let defaultResolvePolicy: ResolvePolicy = {\n  when: 'LAZY',\n  async: 'WAIT',\n};\n\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nexport class Resolvable implements ResolvableLiteral {\n  token: any;\n  policy: ResolvePolicy;\n  resolveFn: Function;\n  deps: any[];\n\n  data: any;\n  resolved = false;\n  promise: Promise<any> = undefined;\n\n  static fromData = (token: any, data: any) => new Resolvable(token, () => data, null, null, data);\n\n  /** This constructor creates a Resolvable copy */\n  constructor(resolvable: Resolvable);\n\n  /** This constructor creates a new Resolvable from the plain old [[ResolvableLiteral]] javascript object */\n  constructor(resolvable: ResolvableLiteral);\n\n  /**\n   * This constructor creates a new `Resolvable`\n   *\n   * #### Example:\n   * ```js\n   * var resolvable1 = new Resolvable('mytoken', http => http.get('foo.json').toPromise(), [Http]);\n   *\n   * var resolvable2 = new Resolvable(UserService, dep => new UserService(dep.data), [SomeDependency]);\n   *\n   * var resolvable1Clone = new Resolvable(resolvable1);\n   * ```\n   *\n   * @param token The new resolvable's injection token, such as `\"userList\"` (a string) or `UserService` (a class).\n   *              When this token is used during injection, the resolved value will be injected.\n   * @param resolveFn The function that returns the resolved value, or a promise for the resolved value\n   * @param deps An array of dependencies, which will be injected into the `resolveFn`\n   * @param policy the [[ResolvePolicy]] defines when and how the Resolvable is processed\n   * @param data Pre-resolved data. If the resolve value is already known, it may be provided here.\n   */\n  constructor(token: any, resolveFn: Function, deps?: any[], policy?: ResolvePolicy, data?: any);\n  constructor(arg1: any, resolveFn?: Function, deps?: any[], policy?: ResolvePolicy, data?: any) {\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error('new Resolvable(): token argument is required');\n      if (!isFunction(resolveFn)) throw new Error('new Resolvable(): resolveFn argument must be a function');\n\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {\n      const literal = <ResolvableLiteral>arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  getPolicy(state: StateObject): ResolvePolicy {\n    const thisPolicy = this.policy || {};\n    const statePolicy = (state && state.resolvePolicy) || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n    };\n  }\n\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n  resolve(resolveContext: ResolveContext, trans?: Transition) {\n    const $q = services.$q;\n\n    // Gets all dependencies from ResolveContext and wait for them to be resolved\n    const getResolvableDependencies = () =>\n      $q.all(\n        resolveContext.getDependencies(this).map((resolvable) => resolvable.get(resolveContext, trans))\n      ) as Promise<any[]>;\n\n    // Invokes the resolve function passing the resolved dependencies as arguments\n    const invokeResolveFn = (resolvedDeps: any[]) => this.resolveFn.apply(null, resolvedDeps);\n    const node: PathNode = resolveContext.findNode(this);\n    const state: StateObject = node && node.state;\n\n    const asyncPolicy: PolicyAsync = this.getPolicy(state).async;\n    const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity;\n\n    // After the final value has been resolved, update the state of the Resolvable\n    const applyResolvedValue = (resolvedValue: any) => {\n      this.data = resolvedValue;\n      this.resolved = true;\n      this.resolveFn = null;\n      trace.traceResolvableResolved(this, trans);\n      return this.data;\n    };\n\n    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n    return (this.promise = $q\n      .when()\n      .then(getResolvableDependencies)\n      .then(invokeResolveFn)\n      .then(customAsyncPolicy)\n      .then(applyResolvedValue));\n  }\n\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n  get(resolveContext: ResolveContext, trans?: Transition): Promise<any> {\n    return this.promise || this.resolve(resolveContext, trans);\n  }\n\n  toString() {\n    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;\n  }\n\n  clone(): Resolvable {\n    return new Resolvable(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}