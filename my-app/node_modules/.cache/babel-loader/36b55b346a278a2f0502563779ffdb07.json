{"ast":null,"code":"import { TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nvar defaultOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null\n};\n\nvar TransitionHook =\n/** @class */\nfunction () {\n  function TransitionHook(transition, stateContext, registeredHook, options) {\n    var _this = this;\n\n    this.transition = transition;\n    this.stateContext = stateContext;\n    this.registeredHook = registeredHook;\n    this.options = options;\n\n    this.isSuperseded = function () {\n      return _this.type.hookPhase === TransitionHookPhase.RUN && !_this.options.transition.isActive();\n    };\n\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n\n\n  TransitionHook.chain = function (hooks, waitFor) {\n    // Chain the next hook off the previous\n    var createHookChainR = function (prev, nextHook) {\n      return prev.then(function () {\n        return nextHook.invokeHook();\n      });\n    };\n\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  };\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n\n\n  TransitionHook.invokeHooks = function (hooks, doneCallback) {\n    for (var idx = 0; idx < hooks.length; idx++) {\n      var hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        var remainingHooks = hooks.slice(idx + 1);\n        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  };\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n\n\n  TransitionHook.runAllHooks = function (hooks) {\n    hooks.forEach(function (hook) {\n      return hook.invokeHook();\n    });\n  };\n\n  TransitionHook.prototype.logError = function (err) {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  };\n\n  TransitionHook.prototype.invokeHook = function () {\n    var _this = this;\n\n    var hook = this.registeredHook;\n    if (hook._deregistered) return;\n    var notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n    var options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    var invokeCallback = function () {\n      return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n    };\n\n    var normalizeErr = function (err) {\n      return Rejection.normalize(err).toPromise();\n    };\n\n    var handleError = function (err) {\n      return hook.eventType.getErrorHandler(_this)(err);\n    };\n\n    var handleResult = function (result) {\n      return hook.eventType.getResultHandler(_this)(result);\n    };\n\n    try {\n      var result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr).then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  };\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n\n\n  TransitionHook.prototype.handleHookResult = function (result) {\n    var _this = this;\n\n    var notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent; // Hook returned a promise\n\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then(function (val) {\n        return _this.handleHookResult(val);\n      });\n    }\n\n    trace.traceHookResult(result, this.transition, this.options); // Hook returned false\n\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted('Hook aborted transition').toPromise();\n    }\n\n    var isTargetState = is(TargetState); // hook returned a TargetState\n\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  };\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n\n\n  TransitionHook.prototype.getNotCurrentRejection = function () {\n    var router = this.transition.router; // The router is stopped\n\n    if (router._disposed) {\n      return Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    } // This transition is no longer current.\n    // Another transition started while this hook was still running.\n\n\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  };\n\n  TransitionHook.prototype.toString = function () {\n    var _a = this,\n        options = _a.options,\n        registeredHook = _a.registeredHook;\n\n    var event = parse('traceData.hookType')(options) || 'internal',\n        context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown',\n        name = fnToString(registeredHook.callback);\n    return event + \" context: \" + context + \", \" + maxLength(200, name);\n  };\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n\n\n  TransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n      return hook.handleHookResult(result);\n    };\n  };\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n\n\n  TransitionHook.LOG_REJECTED_RESULT = function (hook) {\n    return function (result) {\n      isPromise(result) && result.catch(function (err) {\n        return hook.logError(Rejection.normalize(err));\n      });\n      return undefined;\n    };\n  };\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n\n\n  TransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n      return hook.logError(error);\n    };\n  };\n\n  TransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n      return silentRejection(error);\n    };\n  };\n\n  TransitionHook.THROW_ERROR = function (hook) {\n    return function (error) {\n      throw error;\n    };\n  };\n\n  return TransitionHook;\n}();\n\nexport { TransitionHook };","map":{"version":3,"mappings":"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","names":["TransitionHookPhase","defaults","noop","silentRejection","fnToString","maxLength","isPromise","is","parse","trace","services","Rejection","TargetState","defaultOptions","current","transition","traceData","bind","stateContext","registeredHook","options","type","hookPhase","RUN","_this","isActive","eventType","TransitionHook","hooks","waitFor","createHookChainR","prev","nextHook","then","invokeHook","reduce","$q","when","doneCallback","idx","length","hookResult","remainingHooks","slice","chain","forEach","hook","err","router","stateService","defaultErrorHandler","_deregistered","notCurrent","getNotCurrentRejection","traceHookInvocation","invokeCallback","callback","call","normalizeErr","normalize","toPromise","handleError","getErrorHandler","handleResult","result","getResultHandler","synchronous","catch","invokeLimit","invokeCount","deregister","val","handleHookResult","traceHookResult","aborted","isTargetState","redirected","_disposed","$id","_aborted","isSuperseded","superseded","event","context","name","logError","undefined","error"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\transition\\@uirouter\\core\\transition\\transitionHook.ts"],"sourcesContent":["import { TransitionHookOptions, HookResult, TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nimport { Transition } from './transition';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\nimport { StateDeclaration } from '../state/interface';\n\nconst defaultOptions: TransitionHookOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null,\n};\n\nexport type GetResultHandler = (hook: TransitionHook) => ResultHandler;\nexport type GetErrorHandler = (hook: TransitionHook) => ErrorHandler;\n\nexport type ResultHandler = (result: HookResult) => Promise<HookResult>;\nexport type ErrorHandler = (error: any) => Promise<any>;\n\nexport class TransitionHook {\n  type: TransitionEventType;\n\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static HANDLE_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) =>\n    hook.handleHookResult(result);\n\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n  static LOG_REJECTED_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) => {\n    isPromise(result) && result.catch((err) => hook.logError(Rejection.normalize(err)));\n    return undefined;\n  };\n\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static LOG_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => hook.logError(error);\n\n  static REJECT_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => silentRejection(error);\n\n  static THROW_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => {\n    throw error;\n  };\n\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n  static chain(hooks: TransitionHook[], waitFor?: Promise<any>): Promise<any> {\n    // Chain the next hook off the previous\n    const createHookChainR = (prev: Promise<any>, nextHook: TransitionHook) => prev.then(() => nextHook.invokeHook());\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  }\n\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n  static invokeHooks<T>(hooks: TransitionHook[], doneCallback: (result?: HookResult) => T): Promise<any> | T {\n    for (let idx = 0; idx < hooks.length; idx++) {\n      const hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        const remainingHooks = hooks.slice(idx + 1);\n\n        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  }\n\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n  static runAllHooks(hooks: TransitionHook[]): void {\n    hooks.forEach((hook) => hook.invokeHook());\n  }\n\n  constructor(\n    private transition: Transition,\n    private stateContext: StateDeclaration,\n    private registeredHook: RegisteredHook,\n    private options: TransitionHookOptions\n  ) {\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n\n  private isSuperseded = () => this.type.hookPhase === TransitionHookPhase.RUN && !this.options.transition.isActive();\n\n  logError(err): any {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  }\n\n  invokeHook(): Promise<HookResult> | void {\n    const hook = this.registeredHook;\n    if (hook._deregistered) return;\n\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    const options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    const invokeCallback = () => hook.callback.call(options.bind, this.transition, this.stateContext);\n\n    const normalizeErr = (err) => Rejection.normalize(err).toPromise();\n\n    const handleError = (err) => hook.eventType.getErrorHandler(this)(err);\n\n    const handleResult = (result) => hook.eventType.getResultHandler(this)(result);\n\n    try {\n      const result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr).then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  }\n\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n  handleHookResult(result: HookResult): Promise<HookResult> {\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    // Hook returned a promise\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then((val) => this.handleHookResult(val));\n    }\n\n    trace.traceHookResult(result, this.transition, this.options);\n\n    // Hook returned false\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted('Hook aborted transition').toPromise();\n    }\n\n    const isTargetState = is(TargetState);\n    // hook returned a TargetState\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  }\n\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n  private getNotCurrentRejection() {\n    const router = this.transition.router;\n\n    // The router is stopped\n    if (router._disposed) {\n      return Rejection.aborted(`UIRouter instance #${router.$id} has been stopped (disposed)`).toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    }\n\n    // This transition is no longer current.\n    // Another transition started while this hook was still running.\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  }\n\n  toString() {\n    const { options, registeredHook } = this;\n    const event = parse('traceData.hookType')(options) || 'internal',\n      context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown',\n      name = fnToString(registeredHook.callback);\n    return `${event} context: ${context}, ${maxLength(200, name)}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}