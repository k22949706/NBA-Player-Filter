{"ast":null,"code":"/** @publicapi @module view */\n\n/** */\nimport { ng as angular } from './angular';\nimport { isArray, isDefined, isFunction, isObject, services, tail, kebobString, unnestR, Resolvable } from '@uirouter/core';\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\n\nvar TemplateFactory =\n/** @class */\nfunction () {\n  function TemplateFactory() {\n    var _this = this;\n    /** @hidden */\n\n\n    this._useHttp = angular.version.minor < 3;\n    /** @hidden */\n\n    this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n      _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n      _this.$http = $http;\n      _this.$templateCache = $templateCache;\n      return _this;\n    }];\n  }\n  /** @hidden */\n\n\n  TemplateFactory.prototype.useHttpService = function (value) {\n    this._useHttp = value;\n  };\n  /**\n   * Creates a template from a configuration object.\n   *\n   * @param config Configuration object for which to load a template.\n   * The following properties are search in the specified order, and the first one\n   * that is defined is used to create the template:\n   *\n   * @param params  Parameters to pass to the template function.\n   * @param context The resolve context associated with the template's view\n   *\n   * @return {string|object}  The template html as a string, or a promise for\n   * that string,or `null` if no template is configured.\n   */\n\n\n  TemplateFactory.prototype.fromConfig = function (config, params, context) {\n    var defaultTemplate = '<ui-view></ui-view>';\n\n    var asTemplate = function (result) {\n      return services.$q.when(result).then(function (str) {\n        return {\n          template: str\n        };\n      });\n    };\n\n    var asComponent = function (result) {\n      return services.$q.when(result).then(function (str) {\n        return {\n          component: str\n        };\n      });\n    };\n\n    return isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) : isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) : isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) : isDefined(config.component) ? asComponent(config.component) : isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) : asTemplate(defaultTemplate);\n  };\n  /**\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param template html template as a string or function that returns an html template as a string.\n   * @param params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that\n   * string.\n   */\n\n\n  TemplateFactory.prototype.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n  /**\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function\n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n\n\n  TemplateFactory.prototype.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n\n    if (this._useHttp) {\n      return this.$http.get(url, {\n        cache: this.$templateCache,\n        headers: {\n          Accept: 'text/html'\n        }\n      }).then(function (response) {\n        return response.data;\n      });\n    }\n\n    return this.$templateRequest(url);\n  };\n  /**\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n\n\n  TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n    var deps = services.$injector.annotate(provider);\n    var providerFn = isArray(provider) ? tail(provider) : provider;\n    var resolvable = new Resolvable('', providerFn, deps);\n    return resolvable.get(context);\n  };\n  /**\n   * Creates a component's template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n\n\n  TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n    var deps = services.$injector.annotate(provider);\n    var providerFn = isArray(provider) ? tail(provider) : provider;\n    var resolvable = new Resolvable('', providerFn, deps);\n    return resolvable.get(context);\n  };\n  /**\n   * Creates a template from a component's name\n   *\n   * This implements route-to-component.\n   * It works by retrieving the component (directive) metadata from the injector.\n   * It analyses the component's bindings, then constructs a template that instantiates the component.\n   * The template wires input and output bindings to resolves or from the parent component.\n   *\n   * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n   * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n   * @param component {string} Component's name in camel case.\n   * @param bindings An object defining the component's bindings: {foo: '<'}\n   * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n\n\n  TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n    bindings = bindings || {}; // Bind once prefix\n\n    var prefix = angular.version.minor >= 3 ? '::' : ''; // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n\n    var kebob = function (camelCase) {\n      var kebobed = kebobString(camelCase);\n      return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n    };\n\n    var attributeTpl = function (input) {\n      var name = input.name,\n          type = input.type;\n      var attrName = kebob(name); // If the ui-view has an attribute which matches a binding on the routed component\n      // then pass that attribute through to the routed component template.\n      // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n\n      if (uiView.attr(attrName) && !bindings[name]) return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n      var resolveName = bindings[name] || name; // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n      // some-attr=\"{{ ::$resolve.someResolveName }}\"\n\n      if (type === '@') return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\"; // Wire \"&\" callbacks to resolves that return a callback function\n      // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n      // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n\n      if (type === '&') {\n        var res = context.getResolvable(resolveName);\n        var fn = res && res.data;\n        var args = fn && services.$injector.annotate(fn) || []; // account for array style injection, i.e., ['foo', function(foo) {}]\n\n        var arrayIdxStr = isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n        return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(',') + \")'\";\n      } // some-attr=\"::$resolve.someResolveName\"\n\n\n      return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n    };\n\n    var attrs = getComponentBindings(component).map(attributeTpl).join(' ');\n    var kebobName = kebob(component);\n    return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n  };\n\n  return TemplateFactory;\n}();\n\nexport { TemplateFactory }; // Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\n\nfunction getComponentBindings(name) {\n  var cmpDefs = services.$injector.get(name + 'Directive'); // could be multiple\n\n  if (!cmpDefs || !cmpDefs.length) throw new Error(\"Unable to find component named '\" + name + \"'\");\n  return cmpDefs.map(getBindings).reduce(unnestR, []);\n} // Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\n\n\nvar getBindings = function (def) {\n  if (isObject(def.bindToController)) return scopeBindings(def.bindToController);\n  return scopeBindings(def.scope);\n}; // for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\n\n\nvar scopeBindings = function (bindingsObj) {\n  return Object.keys(bindingsObj || {}) // [ 'input', [ '=foo', '=', 'foo' ] ]\n  .map(function (key) {\n    return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])];\n  }) // skip malformed values\n  .filter(function (tuple) {\n    return isDefined(tuple) && isArray(tuple[1]);\n  }) // { name: ('foo' || 'input'), type: '=' }\n  .map(function (tuple) {\n    return {\n      name: tuple[1][2] || tuple[0],\n      type: tuple[1][1]\n    };\n  });\n};","map":{"version":3,"mappings":"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","names":["ng","angular","isArray","isDefined","isFunction","isObject","services","tail","kebobString","unnestR","Resolvable","version","minor","$http","$templateCache","$injector","_this","$templateRequest","has","get","TemplateFactory","value","_useHttp","config","params","context","defaultTemplate","asTemplate","result","$q","when","then","str","template","asComponent","component","fromString","templateUrl","fromUrl","templateProvider","fromProvider","componentProvider","fromComponentProvider","url","cache","headers","Accept","response","data","provider","deps","annotate","providerFn","resolvable","uiView","bindings","prefix","kebob","camelCase","kebobed","exec","attributeTpl","input","type","attrName","name","attr","resolveName","res","getResolvable","fn","args","arrayIdxStr","length","join","attrs","getComponentBindings","map","kebobName","cmpDefs","Error","getBindings","reduce","def","bindToController","scopeBindings","scope","bindingsObj","keys","key","filter","tuple"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\angularjs\\lib-esm\\@uirouter\\angularjs\\templateFactory.ts"],"sourcesContent":["/** @publicapi @module view */ /** */\nimport { ng as angular } from './angular';\nimport { IAugmentedJQuery } from 'angular';\nimport {\n  isArray,\n  isDefined,\n  isFunction,\n  isObject,\n  services,\n  Obj,\n  IInjectable,\n  tail,\n  kebobString,\n  unnestR,\n  ResolveContext,\n  Resolvable,\n  RawParams,\n} from '@uirouter/core';\nimport { Ng1ViewDeclaration, TemplateFactoryProvider } from './interface';\n\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nexport class TemplateFactory implements TemplateFactoryProvider {\n  /** @hidden */ private _useHttp = angular.version.minor < 3;\n  /** @hidden */ private $templateRequest;\n  /** @hidden */ private $templateCache;\n  /** @hidden */ private $http;\n\n  /** @hidden */ $get = [\n    '$http',\n    '$templateCache',\n    '$injector',\n    ($http, $templateCache, $injector) => {\n      this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n      this.$http = $http;\n      this.$templateCache = $templateCache;\n      return this;\n    },\n  ];\n\n  /** @hidden */\n  useHttpService(value: boolean) {\n    this._useHttp = value;\n  }\n\n  /**\n   * Creates a template from a configuration object.\n   *\n   * @param config Configuration object for which to load a template.\n   * The following properties are search in the specified order, and the first one\n   * that is defined is used to create the template:\n   *\n   * @param params  Parameters to pass to the template function.\n   * @param context The resolve context associated with the template's view\n   *\n   * @return {string|object}  The template html as a string, or a promise for\n   * that string,or `null` if no template is configured.\n   */\n  fromConfig(\n    config: Ng1ViewDeclaration,\n    params: any,\n    context: ResolveContext\n  ): Promise<{ template?: string; component?: string }> {\n    const defaultTemplate = '<ui-view></ui-view>';\n\n    const asTemplate = (result) => services.$q.when(result).then((str) => ({ template: str }));\n    const asComponent = (result) => services.$q.when(result).then((str) => ({ component: str }));\n\n    return isDefined(config.template)\n      ? asTemplate(this.fromString(config.template, params))\n      : isDefined(config.templateUrl)\n      ? asTemplate(this.fromUrl(config.templateUrl, params))\n      : isDefined(config.templateProvider)\n      ? asTemplate(this.fromProvider(config.templateProvider, params, context))\n      : isDefined(config.component)\n      ? asComponent(config.component)\n      : isDefined(config.componentProvider)\n      ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))\n      : asTemplate(defaultTemplate);\n  }\n\n  /**\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param template html template as a string or function that returns an html template as a string.\n   * @param params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that\n   * string.\n   */\n  fromString(template: string | Function, params?: RawParams) {\n    return isFunction(template) ? (<any>template)(params) : template;\n  }\n\n  /**\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function\n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromUrl(url: string | Function, params: any) {\n    if (isFunction(url)) url = (<any>url)(params);\n    if (url == null) return null;\n\n    if (this._useHttp) {\n      return this.$http\n        .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n        .then(function (response) {\n          return response.data;\n        });\n    }\n\n    return this.$templateRequest(url);\n  }\n\n  /**\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    const deps = services.$injector.annotate(provider);\n    const providerFn = isArray(provider) ? tail(<any[]>provider) : provider;\n    const resolvable = new Resolvable('', <Function>providerFn, deps);\n    return resolvable.get(context);\n  }\n\n  /**\n   * Creates a component's template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  fromComponentProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    const deps = services.$injector.annotate(provider);\n    const providerFn = isArray(provider) ? tail(<any[]>provider) : provider;\n    const resolvable = new Resolvable('', <Function>providerFn, deps);\n    return resolvable.get(context);\n  }\n\n  /**\n   * Creates a template from a component's name\n   *\n   * This implements route-to-component.\n   * It works by retrieving the component (directive) metadata from the injector.\n   * It analyses the component's bindings, then constructs a template that instantiates the component.\n   * The template wires input and output bindings to resolves or from the parent component.\n   *\n   * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n   * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n   * @param component {string} Component's name in camel case.\n   * @param bindings An object defining the component's bindings: {foo: '<'}\n   * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  makeComponentTemplate(uiView: IAugmentedJQuery, context: ResolveContext, component: string, bindings?: any) {\n    bindings = bindings || {};\n\n    // Bind once prefix\n    const prefix = angular.version.minor >= 3 ? '::' : '';\n    // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n    const kebob = (camelCase: string) => {\n      const kebobed = kebobString(camelCase);\n      return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;\n    };\n\n    const attributeTpl = (input: BindingTuple) => {\n      const { name, type } = input;\n      const attrName = kebob(name);\n      // If the ui-view has an attribute which matches a binding on the routed component\n      // then pass that attribute through to the routed component template.\n      // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n      if (uiView.attr(attrName) && !bindings[name]) return `${attrName}='${uiView.attr(attrName)}'`;\n\n      const resolveName = bindings[name] || name;\n      // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n      // some-attr=\"{{ ::$resolve.someResolveName }}\"\n      if (type === '@') return `${attrName}='{{${prefix}$resolve.${resolveName}}}'`;\n\n      // Wire \"&\" callbacks to resolves that return a callback function\n      // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n      // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n      if (type === '&') {\n        const res = context.getResolvable(resolveName);\n        const fn = res && res.data;\n        const args = (fn && services.$injector.annotate(fn)) || [];\n        // account for array style injection, i.e., ['foo', function(foo) {}]\n        const arrayIdxStr = isArray(fn) ? `[${fn.length - 1}]` : '';\n        return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(',')})'`;\n      }\n\n      // some-attr=\"::$resolve.someResolveName\"\n      return `${attrName}='${prefix}$resolve.${resolveName}'`;\n    };\n\n    const attrs = getComponentBindings(component).map(attributeTpl).join(' ');\n    const kebobName = kebob(component);\n    return `<${kebobName} ${attrs}></${kebobName}>`;\n  }\n}\n\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name: string) {\n  const cmpDefs = <any[]>services.$injector.get(name + 'Directive'); // could be multiple\n  if (!cmpDefs || !cmpDefs.length) throw new Error(`Unable to find component named '${name}'`);\n  return cmpDefs.map(getBindings).reduce(unnestR, []);\n}\n\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nconst getBindings = (def: any) => {\n  if (isObject(def.bindToController)) return scopeBindings(def.bindToController);\n  return scopeBindings(def.scope);\n};\n\ninterface BindingTuple {\n  name: string;\n  type: string;\n}\n\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nconst scopeBindings = (bindingsObj: Obj) =>\n  Object.keys(bindingsObj || {})\n    // [ 'input', [ '=foo', '=', 'foo' ] ]\n    .map((key) => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])])\n    // skip malformed values\n    .filter((tuple) => isDefined(tuple) && isArray(tuple[1]))\n    // { name: ('foo' || 'input'), type: '=' }\n    .map((tuple) => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] } as BindingTuple));\n"]},"metadata":{},"sourceType":"module"}