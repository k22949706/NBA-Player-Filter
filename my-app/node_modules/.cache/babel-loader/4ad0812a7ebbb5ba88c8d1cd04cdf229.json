{"ast":null,"code":"/**\n * Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @packageDocumentation\n */\nimport { and, not, pipe, prop, or } from './hof';\nvar toStr = Object.prototype.toString;\n\nvar tis = function (t) {\n  return function (x) {\n    return typeof x === t;\n  };\n};\n\nexport var isUndefined = tis('undefined');\nexport var isDefined = not(isUndefined);\nexport var isNull = function (o) {\n  return o === null;\n};\nexport var isNullOrUndefined = or(isNull, isUndefined);\nexport var isFunction = tis('function');\nexport var isNumber = tis('number');\nexport var isString = tis('string');\nexport var isObject = function (x) {\n  return x !== null && typeof x === 'object';\n};\nexport var isArray = Array.isArray;\nexport var isDate = function (x) {\n  return toStr.call(x) === '[object Date]';\n};\nexport var isRegExp = function (x) {\n  return toStr.call(x) === '[object RegExp]';\n};\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\n\nexport function isInjectable(val) {\n  if (isArray(val) && val.length) {\n    var head = val.slice(0, -1),\n        tail = val.slice(-1);\n    return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);\n  }\n\n  return isFunction(val);\n}\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\n\nexport var isPromise = and(isObject, pipe(prop('then'), isFunction));","map":{"version":3,"mappings":"AAAA;;;;;;;;AAQA,SAASA,GAAT,EAAcC,GAAd,EAAmBC,IAAnB,EAAyBC,IAAzB,EAA+BC,EAA/B,QAAyC,OAAzC;AAIA,IAAMC,KAAK,GAAGC,MAAM,CAACC,SAAP,CAAiBC,QAA/B;;AACA,IAAMC,GAAG,GAAG,UAACC,CAAD,EAAU;EAAK,iBAACC,CAAD,EAAO;IAAK,cAAOA,CAAP,KAAaD,CAAb;EAAc,CAA1B;AAA0B,CAArD;;AACA,OAAO,IAAME,WAAW,GAAGH,GAAG,CAAC,WAAD,CAAvB;AACP,OAAO,IAAMI,SAAS,GAAGZ,GAAG,CAACW,WAAD,CAArB;AACP,OAAO,IAAME,MAAM,GAAG,UAACC,CAAD,EAAO;EAAK,QAAC,KAAK,IAAN;AAAU,CAArC;AACP,OAAO,IAAMC,iBAAiB,GAAGZ,EAAE,CAACU,MAAD,EAASF,WAAT,CAA5B;AACP,OAAO,IAAMK,UAAU,GAAmCR,GAAG,CAAC,UAAD,CAAtD;AACP,OAAO,IAAMS,QAAQ,GAAiCT,GAAG,CAAC,QAAD,CAAlD;AACP,OAAO,IAAMU,QAAQ,GAA4BV,GAAG,CAAC,QAAD,CAA7C;AACP,OAAO,IAAMW,QAAQ,GAAG,UAACT,CAAD,EAAO;EAAK,QAAC,KAAK,IAAN,IAAc,OAAOA,CAAP,KAAa,QAA3B;AAAmC,CAAhE;AACP,OAAO,IAAMU,OAAO,GAAGC,KAAK,CAACD,OAAtB;AACP,OAAO,IAAME,MAAM,GAAgC,UAACZ,CAAD,EAAO;EAAK,YAAK,CAACa,IAAN,CAAWb,CAAX,MAAkB,eAAlB;AAAiC,CAAzF;AACP,OAAO,IAAMc,QAAQ,GAAkC,UAACd,CAAD,EAAO;EAAK,YAAK,CAACa,IAAN,CAAWb,CAAX,MAAkB,iBAAlB;AAAmC,CAA/F;AAEP;;;;;;;AAMA,OAAM,SAAUe,YAAV,CAAuBC,GAAvB,EAA+B;EACnC,IAAIN,OAAO,CAACM,GAAD,CAAP,IAAgBA,GAAG,CAACC,MAAxB,EAAgC;IAC9B,IAAMC,IAAI,GAAGF,GAAG,CAACG,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,CAAb;IAAA,IACEC,IAAI,GAAGJ,GAAG,CAACG,KAAJ,CAAU,CAAC,CAAX,CADT;IAEA,OAAO,EAAED,IAAI,CAACG,MAAL,CAAY/B,GAAG,CAACkB,QAAD,CAAf,EAA2BS,MAA3B,IAAqCG,IAAI,CAACC,MAAL,CAAY/B,GAAG,CAACgB,UAAD,CAAf,EAA6BW,MAApE,CAAP;EACD;;EACD,OAAOX,UAAU,CAACU,GAAD,CAAjB;AACD;AAED;;;;;;AAKA,OAAO,IAAMM,SAAS,GAAkCjC,GAAG,CAACoB,QAAD,EAAWlB,IAAI,CAACC,IAAI,CAAC,MAAD,CAAL,EAAec,UAAf,CAAf,CAApD","names":["and","not","pipe","prop","or","toStr","Object","prototype","toString","tis","t","x","isUndefined","isDefined","isNull","o","isNullOrUndefined","isFunction","isNumber","isString","isObject","isArray","Array","isDate","call","isRegExp","isInjectable","val","length","head","slice","tail","filter","isPromise"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\common\\@uirouter\\core\\common\\predicates.ts"],"sourcesContent":["/**\n * Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @packageDocumentation\n */\nimport { and, not, pipe, prop, or } from './hof';\nimport { Predicate } from './common'; // has or is using\nimport { StateObject } from '../state/stateObject';\n\nconst toStr = Object.prototype.toString;\nconst tis = (t: string) => (x: any) => typeof x === t;\nexport const isUndefined = tis('undefined');\nexport const isDefined = not(isUndefined);\nexport const isNull = (o: any) => o === null;\nexport const isNullOrUndefined = or(isNull, isUndefined);\nexport const isFunction: (x: any) => x is Function = <any>tis('function');\nexport const isNumber: (x: any) => x is number = <any>tis('number');\nexport const isString = <(x: any) => x is string>tis('string');\nexport const isObject = (x: any) => x !== null && typeof x === 'object';\nexport const isArray = Array.isArray;\nexport const isDate: (x: any) => x is Date = <any>((x: any) => toStr.call(x) === '[object Date]');\nexport const isRegExp: (x: any) => x is RegExp = <any>((x: any) => toStr.call(x) === '[object RegExp]');\n\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nexport function isInjectable(val: any) {\n  if (isArray(val) && val.length) {\n    const head = val.slice(0, -1),\n      tail = val.slice(-1);\n    return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);\n  }\n  return isFunction(val);\n}\n\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexport const isPromise = <(x: any) => x is Promise<any>>and(isObject, pipe(prop('then'), isFunction));\n"]},"metadata":{},"sourceType":"module"}