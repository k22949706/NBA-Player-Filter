{"ast":null,"code":"import { services } from '../common/coreservices';\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\n\nvar lazyLoadHook = function (transition) {\n  var router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      var orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    } // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n\n\n    var $url = router.urlService;\n    var result = $url.match($url.parts());\n    var rule = result && result.rule; // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n\n    if (rule && rule.type === 'STATE') {\n      var state = rule.state;\n      var params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    } // No matching state found, so let .sync() choose the best non-state match/otherwise\n\n\n    router.urlService.sync();\n  }\n\n  var promises = transition.entering().filter(function (state) {\n    return !!state.$$state().lazyLoad;\n  }).map(function (state) {\n    return lazyLoadState(transition, state);\n  });\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport var registerLazyLoadHook = function (transitionService) {\n  return transitionService.onBefore({\n    entering: function (state) {\n      return !!state.lazyLoad;\n    }\n  }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\n\nexport function lazyLoadState(transition, state) {\n  var lazyLoadFn = state.$$state().lazyLoad; // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\n  var promise = lazyLoadFn['_promise'];\n\n  if (!promise) {\n    var success = function (result) {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    var error = function (err) {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] = services.$q.when(lazyLoadFn(transition, state)).then(updateStateRegistry).then(success, error);\n  }\n  /** Register any lazy loaded state definitions */\n\n\n  function updateStateRegistry(result) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach(function (_state) {\n        return transition.router.stateRegistry.register(_state);\n      });\n    }\n\n    return result;\n  }\n\n  return promise;\n}","map":{"version":3,"mappings":"AAIA,SAASA,QAAT,QAAyB,wBAAzB;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,IAAMC,YAAY,GAAqB,UAACC,UAAD,EAAuB;EAC5D,IAAMC,MAAM,GAAGD,UAAU,CAACC,MAA1B;;EAEA,SAASC,eAAT,GAAwB;IACtB,IAAIF,UAAU,CAACG,kBAAX,GAAgCC,OAAhC,GAA0CC,MAA1C,KAAqD,KAAzD,EAAgE;MAC9D;MACA;MACA,IAAMC,IAAI,GAAGN,UAAU,CAACO,WAAX,EAAb;MACA,OAAON,MAAM,CAACO,YAAP,CAAoBC,MAApB,CAA2BH,IAAI,CAACI,UAAL,EAA3B,EAA8CJ,IAAI,CAACK,MAAL,EAA9C,EAA6DL,IAAI,CAACF,OAAL,EAA7D,CAAP;IACD,CANqB,CAQtB;IACA;;;IACA,IAAMQ,IAAI,GAAGX,MAAM,CAACY,UAApB;IACA,IAAMC,MAAM,GAAGF,IAAI,CAACG,KAAL,CAAWH,IAAI,CAACI,KAAL,EAAX,CAAf;IACA,IAAMC,IAAI,GAAGH,MAAM,IAAIA,MAAM,CAACG,IAA9B,CAZsB,CActB;IACA;;IACA,IAAIA,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAc,OAA1B,EAAmC;MACjC,IAAMC,KAAK,GAAIF,IAAkB,CAACE,KAAlC;MACA,IAAMR,MAAM,GAAGG,MAAM,CAACC,KAAtB;MACA,OAAOd,MAAM,CAACO,YAAP,CAAoBC,MAApB,CAA2BU,KAA3B,EAAkCR,MAAlC,EAA0CX,UAAU,CAACI,OAAX,EAA1C,CAAP;IACD,CApBqB,CAsBtB;;;IACAH,MAAM,CAACY,UAAP,CAAkBO,IAAlB;EACD;;EAED,IAAMC,QAAQ,GAAGrB,UAAU,CACxBsB,QADc,GAEdC,MAFc,CAEP,UAACJ,KAAD,EAAM;IAAK,QAAC,CAACA,KAAK,CAACK,OAAN,GAAgBC,QAAlB;EAA0B,CAF9B,EAGdC,GAHc,CAGV,UAACP,KAAD,EAAM;IAAK,oBAAa,CAACnB,UAAD,EAAamB,KAAb,CAAb;EAAgC,CAHjC,CAAjB;EAKA,OAAOrB,QAAQ,CAAC6B,EAAT,CAAYC,GAAZ,CAAgBP,QAAhB,EAA0BQ,IAA1B,CAA+B3B,eAA/B,CAAP;AACD,CAnCD;;AAqCA,OAAO,IAAM4B,oBAAoB,GAAG,UAACC,iBAAD,EAAqC;EACvE,wBAAiB,CAACC,QAAlB,CAA2B;IAAEV,QAAQ,EAAE,UAACH,KAAD,EAAM;MAAK,QAAC,CAACA,KAAK,CAACM,QAAR;IAAgB;EAAvC,CAA3B,EAAsE1B,YAAtE;AAAmF,CAD9E;AAGP;;;;;;;;AAOA,OAAM,SAAUkC,aAAV,CAAwBjC,UAAxB,EAAgDmB,KAAhD,EAAuE;EAC3E,IAAMe,UAAU,GAAGf,KAAK,CAACK,OAAN,GAAgBC,QAAnC,CAD2E,CAG3E;;EACA,IAAIU,OAAO,GAAGD,UAAU,CAAC,UAAD,CAAxB;;EACA,IAAI,CAACC,OAAL,EAAc;IACZ,IAAMC,OAAO,GAAG,UAACtB,MAAD,EAAO;MACrB,OAAOK,KAAK,CAACM,QAAb;MACA,OAAON,KAAK,CAACK,OAAN,GAAgBC,QAAvB;MACA,OAAOS,UAAU,CAAC,UAAD,CAAjB;MACA,OAAOpB,MAAP;IACD,CALD;;IAOA,IAAMuB,KAAK,GAAG,UAACC,GAAD,EAAI;MAChB,OAAOJ,UAAU,CAAC,UAAD,CAAjB;MACA,OAAOpC,QAAQ,CAAC6B,EAAT,CAAYY,MAAZ,CAAmBD,GAAnB,CAAP;IACD,CAHD;;IAKAH,OAAO,GAAGD,UAAU,CAAC,UAAD,CAAV,GAAyBpC,QAAQ,CAAC6B,EAAT,CAChCa,IADgC,CAC3BN,UAAU,CAAClC,UAAD,EAAamB,KAAb,CADiB,EAEhCU,IAFgC,CAE3BY,mBAF2B,EAGhCZ,IAHgC,CAG3BO,OAH2B,EAGlBC,KAHkB,CAAnC;EAID;EAED;;;EACA,SAASI,mBAAT,CAA6B3B,MAA7B,EAAmD;IACjD,IAAIA,MAAM,IAAI4B,KAAK,CAACC,OAAN,CAAc7B,MAAM,CAAC8B,MAArB,CAAd,EAA4C;MAC1C9B,MAAM,CAAC8B,MAAP,CAAcC,OAAd,CAAsB,UAACC,MAAD,EAAO;QAAK,iBAAU,CAAC7C,MAAX,CAAkB8C,aAAlB,CAAgCC,QAAhC,CAAyCF,MAAzC;MAAgD,CAAlF;IACD;;IACD,OAAOhC,MAAP;EACD;;EAED,OAAOqB,OAAP;AACD","names":["services","lazyLoadHook","transition","router","retryTransition","originalTransition","options","source","orig","targetState","stateService","target","identifier","params","$url","urlService","result","match","parts","rule","type","state","sync","promises","entering","filter","$$state","lazyLoad","map","$q","all","then","registerLazyLoadHook","transitionService","onBefore","lazyLoadState","lazyLoadFn","promise","success","error","err","reject","when","updateStateRegistry","Array","isArray","states","forEach","_state","stateRegistry","register"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\hooks\\@uirouter\\core\\hooks\\lazyLoad.ts"],"sourcesContent":["import { Transition } from '../transition/transition';\nimport { TransitionService } from '../transition/transitionService';\nimport { TransitionHookFn } from '../transition/interface';\nimport { StateDeclaration, LazyLoadResult } from '../state/interface';\nimport { services } from '../common/coreservices';\nimport { StateRule } from '../url/interface';\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nconst lazyLoadHook: TransitionHookFn = (transition: Transition) => {\n  const router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      const orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    }\n\n    // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n    const $url = router.urlService;\n    const result = $url.match($url.parts());\n    const rule = result && result.rule;\n\n    // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n    if (rule && rule.type === 'STATE') {\n      const state = (rule as StateRule).state;\n      const params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    }\n\n    // No matching state found, so let .sync() choose the best non-state match/otherwise\n    router.urlService.sync();\n  }\n\n  const promises = transition\n    .entering()\n    .filter((state) => !!state.$$state().lazyLoad)\n    .map((state) => lazyLoadState(transition, state));\n\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport const registerLazyLoadHook = (transitionService: TransitionService) =>\n  transitionService.onBefore({ entering: (state) => !!state.lazyLoad }, lazyLoadHook);\n\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nexport function lazyLoadState(transition: Transition, state: StateDeclaration): Promise<LazyLoadResult> {\n  const lazyLoadFn = state.$$state().lazyLoad;\n\n  // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n  let promise = lazyLoadFn['_promise'];\n  if (!promise) {\n    const success = (result) => {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    const error = (err) => {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] = services.$q\n      .when(lazyLoadFn(transition, state))\n      .then(updateStateRegistry)\n      .then(success, error);\n  }\n\n  /** Register any lazy loaded state definitions */\n  function updateStateRegistry(result: LazyLoadResult) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach((_state) => transition.router.stateRegistry.register(_state));\n    }\n    return result;\n  }\n\n  return promise;\n}\n"]},"metadata":{},"sourceType":"module"}