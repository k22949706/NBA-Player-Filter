{"ast":null,"code":"import { find, tail, uniqR, unnestR, inArray } from '../common/common';\nimport { propEq, not } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { resolvePolicies } from './interface';\nimport { Resolvable } from './resolvable';\nimport { PathUtils } from '../path/pathUtils';\nimport { stringify } from '../common/strings';\nimport { isUndefined } from '../common';\nvar whens = resolvePolicies.when;\nvar ALL_WHENS = [whens.EAGER, whens.LAZY];\nvar EAGER_WHENS = [whens.EAGER]; // tslint:disable-next-line:no-inferrable-types\n\nexport var NATIVE_INJECTOR_TOKEN = 'Native Injector';\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\n\nvar ResolveContext =\n/** @class */\nfunction () {\n  function ResolveContext(_path) {\n    this._path = _path;\n  }\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n\n\n  ResolveContext.prototype.getTokens = function () {\n    return this._path.reduce(function (acc, node) {\n      return acc.concat(node.resolvables.map(function (r) {\n        return r.token;\n      }));\n    }, []).reduce(uniqR, []);\n  };\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n\n\n  ResolveContext.prototype.getResolvable = function (token) {\n    var matching = this._path.map(function (node) {\n      return node.resolvables;\n    }).reduce(unnestR, []).filter(function (r) {\n      return r.token === token;\n    });\n\n    return tail(matching);\n  };\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\n\n  ResolveContext.prototype.getPolicy = function (resolvable) {\n    var node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  };\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n\n\n  ResolveContext.prototype.subContext = function (state) {\n    return new ResolveContext(PathUtils.subPath(this._path, function (node) {\n      return node.state === state;\n    }));\n  };\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n\n\n  ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n    var node = find(this._path, propEq('state', state));\n    var keys = newResolvables.map(function (r) {\n      return r.token;\n    });\n    node.resolvables = node.resolvables.filter(function (r) {\n      return keys.indexOf(r.token) === -1;\n    }).concat(newResolvables);\n  };\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n\n\n  ResolveContext.prototype.resolvePath = function (when, trans) {\n    var _this = this;\n\n    if (when === void 0) {\n      when = 'LAZY';\n    } // This option determines which 'when' policy Resolvables we are about to fetch.\n\n\n    var whenOption = inArray(ALL_WHENS, when) ? when : 'LAZY'; // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\n    var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS; // get the subpath to the state argument, if provided\n\n    trace.traceResolvePath(this._path, when, trans);\n\n    var matchesPolicy = function (acceptedVals, whenOrAsync) {\n      return function (resolvable) {\n        return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n      };\n    }; // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n\n\n    var promises = this._path.reduce(function (acc, node) {\n      var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async'))); // For the matching Resolvables, start their async fetch process.\n\n      var subContext = _this.subContext(node.state);\n\n      var getResult = function (r) {\n        return r.get(subContext, trans) // Return a tuple that includes the Resolvable's token\n        .then(function (value) {\n          return {\n            token: r.token,\n            value: value\n          };\n        });\n      };\n\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []); // Wait for all the \"WAIT\" resolvables\n\n\n    return services.$q.all(promises);\n  };\n\n  ResolveContext.prototype.injector = function () {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  };\n\n  ResolveContext.prototype.findNode = function (resolvable) {\n    return find(this._path, function (node) {\n      return inArray(node.resolvables, resolvable);\n    });\n  };\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n\n\n  ResolveContext.prototype.getDependencies = function (resolvable) {\n    var _this = this;\n\n    var node = this.findNode(resolvable); // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\n    var subPath = PathUtils.subPath(this._path, function (x) {\n      return x === node;\n    }) || this._path;\n\n    var availableResolvables = subPath.reduce(function (acc, _node) {\n      return acc.concat(_node.resolvables);\n    }, []) // all of subpath's resolvables\n    .filter(function (res) {\n      return res !== resolvable;\n    }); // filter out the `resolvable` argument\n\n    var getDependency = function (token) {\n      var matching = availableResolvables.filter(function (r) {\n        return r.token === token;\n      });\n      if (matching.length) return tail(matching);\n\n      var fromInjector = _this.injector().getNative(token);\n\n      if (isUndefined(fromInjector)) {\n        throw new Error('Could not find Dependency Injection token: ' + stringify(token));\n      }\n\n      return new Resolvable(token, function () {\n        return fromInjector;\n      }, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  };\n\n  return ResolveContext;\n}();\n\nexport { ResolveContext };\n/** @internal */\n\nvar UIInjectorImpl =\n/** @class */\nfunction () {\n  function UIInjectorImpl(context) {\n    this.context = context;\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  UIInjectorImpl.prototype.get = function (token) {\n    var resolvable = this.context.getResolvable(token);\n\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));\n      }\n\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  };\n\n  UIInjectorImpl.prototype.getAsync = function (token) {\n    var resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  };\n\n  UIInjectorImpl.prototype.getNative = function (token) {\n    return this.native && this.native.get(token);\n  };\n\n  return UIInjectorImpl;\n}();","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,EAAeC,IAAf,EAAqBC,KAArB,EAA4BC,OAA5B,EAAqCC,OAArC,QAAoD,kBAApD;AACA,SAASC,MAAT,EAAiBC,GAAjB,QAA4B,eAA5B;AACA,SAASC,KAAT,QAAsB,iBAAtB;AACA,SAASC,QAAT,QAAwC,wBAAxC;AACA,SAASC,eAAT,QAA2D,aAA3D;AAEA,SAASC,UAAT,QAA2B,cAA3B;AAEA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,SAAT,QAA0B,mBAA1B;AAGA,SAASC,WAAT,QAA4B,WAA5B;AAEA,IAAMC,KAAK,GAAGL,eAAe,CAACM,IAA9B;AACA,IAAMC,SAAS,GAAG,CAACF,KAAK,CAACG,KAAP,EAAcH,KAAK,CAACI,IAApB,CAAlB;AACA,IAAMC,WAAW,GAAG,CAACL,KAAK,CAACG,KAAP,CAApB,C,CAEA;;AACA,OAAO,IAAMG,qBAAqB,GAAW,iBAAtC;AAEP;;;;;;;;;;;AAUA;AAAA;AAAA;EAGE,wBAAoBC,KAApB,EAAqC;IAAjB;EAAqB;EAEzC;;;EACAC;IACE,OAAO,KAAKD,KAAL,CAAWE,MAAX,CAAkB,UAACC,GAAD,EAAMC,IAAN,EAAU;MAAK,UAAG,CAACC,MAAJ,CAAWD,IAAI,CAACE,WAAL,CAAiBC,GAAjB,CAAqB,UAACC,CAAD,EAAE;QAAK,QAAC,CAACC,KAAF;MAAO,CAAnC,CAAX;IAAgD,CAAjF,EAAmF,EAAnF,EAAuFP,MAAvF,CAA8FrB,KAA9F,EAAqG,EAArG,CAAP;EACD,CAFD;EAIA;;;;;;;;EAMAoB,mDAAcQ,KAAd,EAAwB;IACtB,IAAMC,QAAQ,GAAG,KAAKV,KAAL,CACdO,GADc,CACV,UAACH,IAAD,EAAK;MAAK,WAAI,CAACE,WAAL;IAAgB,CADhB,EAEdJ,MAFc,CAEPpB,OAFO,EAEE,EAFF,EAGd6B,MAHc,CAGP,UAACH,CAAD,EAAc;MAAK,QAAC,CAACC,KAAF,KAAYA,KAAZ;IAAiB,CAH7B,CAAjB;;IAIA,OAAO7B,IAAI,CAAC8B,QAAD,CAAX;EACD,CAND;EAQA;;;EACAT,+CAAUW,UAAV,EAAgC;IAC9B,IAAMR,IAAI,GAAG,KAAKS,QAAL,CAAcD,UAAd,CAAb;IACA,OAAOA,UAAU,CAACE,SAAX,CAAqBV,IAAI,CAACW,KAA1B,CAAP;EACD,CAHD;EAKA;;;;;;;;;;;;;;;;;;;;;;;;;EAuBAd,gDAAWc,KAAX,EAA6B;IAC3B,OAAO,IAAId,cAAJ,CAAmBX,SAAS,CAAC0B,OAAV,CAAkB,KAAKhB,KAAvB,EAA8B,UAACI,IAAD,EAAK;MAAK,WAAI,CAACW,KAAL,KAAeA,KAAf;IAAoB,CAA5D,CAAnB,CAAP;EACD,CAFD;EAIA;;;;;;;;;;;;;;;;;EAeAd,oDAAegB,cAAf,EAA6CF,KAA7C,EAA+D;IAC7D,IAAMX,IAAI,GAAazB,IAAI,CAAC,KAAKqB,KAAN,EAAahB,MAAM,CAAC,OAAD,EAAU+B,KAAV,CAAnB,CAA3B;IACA,IAAMG,IAAI,GAAGD,cAAc,CAACV,GAAf,CAAmB,UAACC,CAAD,EAAE;MAAK,QAAC,CAACC,KAAF;IAAO,CAAjC,CAAb;IACAL,IAAI,CAACE,WAAL,GAAmBF,IAAI,CAACE,WAAL,CAAiBK,MAAjB,CAAwB,UAACH,CAAD,EAAE;MAAK,WAAI,CAACW,OAAL,CAAaX,CAAC,CAACC,KAAf,MAA0B,CAAC,CAA3B;IAA4B,CAA3D,EAA6DJ,MAA7D,CAAoEY,cAApE,CAAnB;EACD,CAJD;EAMA;;;;;;;;;EAOAhB,iDAAYP,IAAZ,EAAuC0B,KAAvC,EAAyD;IAAzD;;IAAY;MAAA1B;IAAyB,CAAoB,CACvD;;;IACA,IAAM2B,UAAU,GAAWtC,OAAO,CAACY,SAAD,EAAYD,IAAZ,CAAP,GAA2BA,IAA3B,GAAkC,MAA7D,CAFuD,CAGvD;IACA;;IACA,IAAM4B,YAAY,GAAGD,UAAU,KAAKjC,eAAe,CAACM,IAAhB,CAAqBE,KAApC,GAA4CE,WAA5C,GAA0DH,SAA/E,CALuD,CAOvD;;IACAT,KAAK,CAACqC,gBAAN,CAAuB,KAAKvB,KAA5B,EAAmCN,IAAnC,EAAyC0B,KAAzC;;IAEA,IAAMI,aAAa,GAAG,UAACC,YAAD,EAAyBC,WAAzB,EAAsD;MAAK,iBAACd,UAAD,EAAuB;QACtG,cAAO,CAACa,YAAD,EAAeE,KAAI,CAACb,SAAL,CAAeF,UAAf,EAA2Bc,WAA3B,CAAf,CAAP;MAA8D,CADiB;IACjB,CADhE,CAVuD,CAavD;IACA;;;IACA,IAAME,QAAQ,GAAmB,KAAK5B,KAAL,CAAWE,MAAX,CAAkB,UAACC,GAAD,EAAMC,IAAN,EAAU;MAC3D,IAAMyB,eAAe,GAAGzB,IAAI,CAACE,WAAL,CAAiBK,MAAjB,CAAwBa,aAAa,CAACF,YAAD,EAAe,MAAf,CAArC,CAAxB;MACA,IAAMQ,MAAM,GAAGD,eAAe,CAAClB,MAAhB,CAAuBa,aAAa,CAAC,CAAC,QAAD,CAAD,EAAa,OAAb,CAApC,CAAf;MACA,IAAMO,IAAI,GAAGF,eAAe,CAAClB,MAAhB,CAAuB1B,GAAG,CAACuC,aAAa,CAAC,CAAC,QAAD,CAAD,EAAa,OAAb,CAAd,CAA1B,CAAb,CAH2D,CAK3D;;MACA,IAAMQ,UAAU,GAAGL,KAAI,CAACK,UAAL,CAAgB5B,IAAI,CAACW,KAArB,CAAnB;;MACA,IAAMkB,SAAS,GAAG,UAACzB,CAAD,EAAc;QAC9B,QAAC,CACE0B,GADH,CACOF,UADP,EACmBZ,KADnB,EAEE;QAFF,CAGGe,IAHH,CAGQ,UAACC,KAAD,EAAM;UAAK,OAAC;YAAE3B,KAAK,EAAED,CAAC,CAACC,KAAX;YAAkB2B,KAAK,EAAEA;UAAzB,CAAD;QAAkC,CAHrD;MAGsD,CAJxD;;MAKAN,MAAM,CAACO,OAAP,CAAeJ,SAAf;MACA,OAAO9B,GAAG,CAACE,MAAJ,CAAW0B,IAAI,CAACxB,GAAL,CAAS0B,SAAT,CAAX,CAAP;IACD,CAdgC,EAc9B,EAd8B,CAAjC,CAfuD,CA+BvD;;;IACA,OAAO9C,QAAQ,CAACmD,EAAT,CAAYC,GAAZ,CAAgBX,QAAhB,CAAP;EACD,CAjCD;;EAmCA3B;IACE,OAAO,KAAKuC,SAAL,KAAmB,KAAKA,SAAL,GAAiB,IAAIC,cAAJ,CAAmB,IAAnB,CAApC,CAAP;EACD,CAFD;;EAIAxC,8CAASW,UAAT,EAA+B;IAC7B,OAAOjC,IAAI,CAAC,KAAKqB,KAAN,EAAa,UAACI,IAAD,EAAe;MAAK,cAAO,CAACA,IAAI,CAACE,WAAN,EAAmBM,UAAnB,CAAP;IAAqC,CAAtE,CAAX;EACD,CAFD;EAIA;;;;;;;EAKAX,qDAAgBW,UAAhB,EAAsC;IAAtC;;IACE,IAAMR,IAAI,GAAG,KAAKS,QAAL,CAAcD,UAAd,CAAb,CADoC,CAEpC;IACA;;IACA,IAAMI,OAAO,GAAe1B,SAAS,CAAC0B,OAAV,CAAkB,KAAKhB,KAAvB,EAA8B,UAAC0C,CAAD,EAAE;MAAK,QAAC,KAAKtC,IAAN;IAAU,CAA/C,KAAoD,KAAKJ,KAArF;;IACA,IAAM2C,oBAAoB,GAAiB3B,OAAO,CAC/Cd,MADwC,CACjC,UAACC,GAAD,EAAMyC,KAAN,EAAW;MAAK,UAAG,CAACvC,MAAJ,CAAWuC,KAAK,CAACtC,WAAjB;IAA6B,CADZ,EACc,EADd,EACkB;IADlB,CAExCK,MAFwC,CAEjC,UAACkC,GAAD,EAAI;MAAK,UAAG,KAAKjC,UAAR;IAAkB,CAFM,CAA3C,CALoC,CAOI;;IAExC,IAAMkC,aAAa,GAAG,UAACrC,KAAD,EAAW;MAC/B,IAAMC,QAAQ,GAAGiC,oBAAoB,CAAChC,MAArB,CAA4B,UAACH,CAAD,EAAE;QAAK,QAAC,CAACC,KAAF,KAAYA,KAAZ;MAAiB,CAApD,CAAjB;MACA,IAAIC,QAAQ,CAACqC,MAAb,EAAqB,OAAOnE,IAAI,CAAC8B,QAAD,CAAX;;MAErB,IAAMsC,YAAY,GAAGrB,KAAI,CAACsB,QAAL,GAAgBC,SAAhB,CAA0BzC,KAA1B,CAArB;;MACA,IAAIjB,WAAW,CAACwD,YAAD,CAAf,EAA+B;QAC7B,MAAM,IAAIG,KAAJ,CAAU,gDAAgD5D,SAAS,CAACkB,KAAD,CAAnE,CAAN;MACD;;MAED,OAAO,IAAIpB,UAAJ,CAAeoB,KAAf,EAAsB;QAAM;MAAY,CAAxC,EAA0C,EAA1C,EAA8CuC,YAA9C,CAAP;IACD,CAVD;;IAYA,OAAOpC,UAAU,CAACwC,IAAX,CAAgB7C,GAAhB,CAAoBuC,aAApB,CAAP;EACD,CAtBD;;EAuBF;AAAC,CA5JD;;;AA8JA;;AACA;AAAA;AAAA;EAGE,wBAAmBO,OAAnB,EAA0C;IAAvB;IACjB,KAAKC,MAAL,GAAc,KAAKpB,GAAL,CAASnC,qBAAT,KAAmCZ,QAAQ,CAACoE,SAA1D;EACD;;EAEDd,yCAAIhC,KAAJ,EAAc;IACZ,IAAMG,UAAU,GAAG,KAAKyC,OAAL,CAAaG,aAAb,CAA2B/C,KAA3B,CAAnB;;IACA,IAAIG,UAAJ,EAAgB;MACd,IAAI,KAAKyC,OAAL,CAAavC,SAAb,CAAuBF,UAAvB,EAAmC6C,KAAnC,KAA6C,QAAjD,EAA2D;QACzD,OAAO7C,UAAU,CAACsB,GAAX,CAAe,KAAKmB,OAApB,CAAP;MACD;;MAED,IAAI,CAACzC,UAAU,CAAC8C,QAAhB,EAA0B;QACxB,MAAM,IAAIP,KAAJ,CAAU,0CAA0C5D,SAAS,CAACqB,UAAU,CAACH,KAAZ,CAA7D,CAAN;MACD;;MACD,OAAOG,UAAU,CAAC+C,IAAlB;IACD;;IAED,OAAO,KAAKT,SAAL,CAAezC,KAAf,CAAP;EACD,CAdD;;EAgBAgC,8CAAShC,KAAT,EAAmB;IACjB,IAAMG,UAAU,GAAG,KAAKyC,OAAL,CAAaG,aAAb,CAA2B/C,KAA3B,CAAnB;IACA,IAAIG,UAAJ,EAAgB,OAAOA,UAAU,CAACsB,GAAX,CAAe,KAAKmB,OAApB,CAAP;IAChB,OAAOlE,QAAQ,CAACmD,EAAT,CAAY5C,IAAZ,CAAiB,KAAK4D,MAAL,CAAYpB,GAAZ,CAAgBzB,KAAhB,CAAjB,CAAP;EACD,CAJD;;EAMAgC,+CAAUhC,KAAV,EAAoB;IAClB,OAAO,KAAK6C,MAAL,IAAe,KAAKA,MAAL,CAAYpB,GAAZ,CAAgBzB,KAAhB,CAAtB;EACD,CAFD;;EAGF;AAAC,CAhCD","names":["find","tail","uniqR","unnestR","inArray","propEq","not","trace","services","resolvePolicies","Resolvable","PathUtils","stringify","isUndefined","whens","when","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","ResolveContext","reduce","acc","node","concat","resolvables","map","r","token","matching","filter","resolvable","findNode","getPolicy","state","subPath","newResolvables","keys","indexOf","trans","whenOption","matchedWhens","traceResolvePath","matchesPolicy","acceptedVals","whenOrAsync","_this","promises","nodeResolvables","nowait","wait","subContext","getResult","get","then","value","forEach","$q","all","_injector","UIInjectorImpl","x","availableResolvables","_node","res","getDependency","length","fromInjector","injector","getNative","Error","deps","context","native","$injector","getResolvable","async","resolved","data"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\resolve\\@uirouter\\core\\resolve\\resolveContext.ts"],"sourcesContent":["import { find, tail, uniqR, unnestR, inArray } from '../common/common';\nimport { propEq, not } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services, $InjectorLike } from '../common/coreservices';\nimport { resolvePolicies, PolicyWhen, ResolvePolicy } from './interface';\nimport { PathNode } from '../path/pathNode';\nimport { Resolvable } from './resolvable';\nimport { StateObject } from '../state/stateObject';\nimport { PathUtils } from '../path/pathUtils';\nimport { stringify } from '../common/strings';\nimport { Transition } from '../transition/transition';\nimport { UIInjector } from '../interface';\nimport { isUndefined } from '../common';\n\nconst whens = resolvePolicies.when;\nconst ALL_WHENS = [whens.EAGER, whens.LAZY];\nconst EAGER_WHENS = [whens.EAGER];\n\n// tslint:disable-next-line:no-inferrable-types\nexport const NATIVE_INJECTOR_TOKEN: string = 'Native Injector';\n\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nexport class ResolveContext {\n  _injector: UIInjector;\n\n  constructor(private _path: PathNode[]) {}\n\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n  getTokens(): any[] {\n    return this._path.reduce((acc, node) => acc.concat(node.resolvables.map((r) => r.token)), []).reduce(uniqR, []);\n  }\n\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n  getResolvable(token: any): Resolvable {\n    const matching = this._path\n      .map((node) => node.resolvables)\n      .reduce(unnestR, [])\n      .filter((r: Resolvable) => r.token === token);\n    return tail(matching);\n  }\n\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n  getPolicy(resolvable: Resolvable): ResolvePolicy {\n    const node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  }\n\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n  subContext(state: StateObject): ResolveContext {\n    return new ResolveContext(PathUtils.subPath(this._path, (node) => node.state === state));\n  }\n\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n  addResolvables(newResolvables: Resolvable[], state: StateObject) {\n    const node = <PathNode>find(this._path, propEq('state', state));\n    const keys = newResolvables.map((r) => r.token);\n    node.resolvables = node.resolvables.filter((r) => keys.indexOf(r.token) === -1).concat(newResolvables);\n  }\n\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n  resolvePath(when: PolicyWhen = 'LAZY', trans?: Transition): Promise<{ token: any; value: any }[]> {\n    // This option determines which 'when' policy Resolvables we are about to fetch.\n    const whenOption: string = inArray(ALL_WHENS, when) ? when : 'LAZY';\n    // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n    const matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\n    // get the subpath to the state argument, if provided\n    trace.traceResolvePath(this._path, when, trans);\n\n    const matchesPolicy = (acceptedVals: string[], whenOrAsync: 'when' | 'async') => (resolvable: Resolvable) =>\n      inArray(acceptedVals, this.getPolicy(resolvable)[whenOrAsync]);\n\n    // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n    const promises: Promise<any>[] = this._path.reduce((acc, node) => {\n      const nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      const nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      const wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n\n      // For the matching Resolvables, start their async fetch process.\n      const subContext = this.subContext(node.state);\n      const getResult = (r: Resolvable) =>\n        r\n          .get(subContext, trans)\n          // Return a tuple that includes the Resolvable's token\n          .then((value) => ({ token: r.token, value: value }));\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []);\n\n    // Wait for all the \"WAIT\" resolvables\n    return services.$q.all(promises);\n  }\n\n  injector(): UIInjector {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  }\n\n  findNode(resolvable: Resolvable): PathNode {\n    return find(this._path, (node: PathNode) => inArray(node.resolvables, resolvable));\n  }\n\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n  getDependencies(resolvable: Resolvable): Resolvable[] {\n    const node = this.findNode(resolvable);\n    // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n    const subPath: PathNode[] = PathUtils.subPath(this._path, (x) => x === node) || this._path;\n    const availableResolvables: Resolvable[] = subPath\n      .reduce((acc, _node) => acc.concat(_node.resolvables), []) // all of subpath's resolvables\n      .filter((res) => res !== resolvable); // filter out the `resolvable` argument\n\n    const getDependency = (token: any) => {\n      const matching = availableResolvables.filter((r) => r.token === token);\n      if (matching.length) return tail(matching);\n\n      const fromInjector = this.injector().getNative(token);\n      if (isUndefined(fromInjector)) {\n        throw new Error('Could not find Dependency Injection token: ' + stringify(token));\n      }\n\n      return new Resolvable(token, () => fromInjector, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  }\n}\n\n/** @internal */\nclass UIInjectorImpl implements UIInjector {\n  native: $InjectorLike;\n\n  constructor(public context: ResolveContext) {\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  get(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));\n      }\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  }\n\n  getAsync(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  }\n\n  getNative(token: any) {\n    return this.native && this.native.get(token);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}