{"ast":null,"code":"import { extend, filter, map, allTrueR, find } from '../common/common';\nimport { prop } from '../common/hof';\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from '../common/predicates';\nimport { services } from '../common/coreservices';\nimport { ParamType } from './paramType';\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nvar isShorthand = function (cfg) {\n  return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n\nvar DefType;\n\n(function (DefType) {\n  DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n  DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n  DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType || (DefType = {}));\n\nexport { DefType };\n\nfunction getParamDeclaration(paramName, location, state) {\n  var noReloadOnSearch = state.reloadOnSearch === false && location === DefType.SEARCH || undefined;\n  var dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n  var defaultConfig = isDefined(dynamic) ? {\n    dynamic: dynamic\n  } : {};\n  var paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);\n  return extend(defaultConfig, paramConfig);\n}\n\nfunction unwrapShorthand(cfg) {\n  cfg = isShorthand(cfg) ? {\n    value: cfg\n  } : cfg;\n  getStaticDefaultValue['__cacheable'] = true;\n\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  var $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n  return extend(cfg, {\n    $$fn: $$fn\n  });\n}\n\nfunction getType(cfg, urlType, location, id, paramTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type)) return paramTypes.type(cfg.type);\n  if (urlType) return urlType;\n\n  if (!cfg.type) {\n    var type = location === DefType.CONFIG ? 'any' : location === DefType.PATH ? 'path' : location === DefType.SEARCH ? 'query' : 'string';\n    return paramTypes.type(type);\n  }\n\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/** returns false, true, or the squash value to indicate the \"default parameter url squash policy\". */\n\n\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n  var squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n\nfunction getReplace(config, arrayMode, isOptional, squash) {\n  var defaultPolicy = [{\n    from: '',\n    to: isOptional || arrayMode ? undefined : ''\n  }, {\n    from: null,\n    to: isOptional || arrayMode ? undefined : ''\n  }];\n  var replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({\n    from: squash,\n    to: undefined\n  });\n  var configuredKeys = map(replace, prop('from'));\n  return filter(defaultPolicy, function (item) {\n    return configuredKeys.indexOf(item.from) === -1;\n  }).concat(replace);\n}\n\nvar Param =\n/** @class */\nfunction () {\n  function Param(id, type, location, urlConfig, state) {\n    var config = getParamDeclaration(id, location, state);\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    var isOptional = config.value !== undefined || location === DefType.SEARCH;\n    var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    var squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n    var inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit; // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\n    function getArrayMode() {\n      var arrayDefaults = {\n        array: location === DefType.SEARCH ? 'auto' : false\n      };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? {\n        array: true\n      } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      isOptional: isOptional,\n      dynamic: dynamic,\n      raw: raw,\n      squash: squash,\n      replace: replace,\n      inherit: inherit,\n      array: arrayMode,\n      config: config\n    });\n  }\n\n  Param.values = function (params, values) {\n    if (values === void 0) {\n      values = {};\n    }\n\n    var paramValues = {};\n\n    for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n      var param = params_1[_i];\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n\n    return paramValues;\n  };\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n\n\n  Param.changed = function (params, values1, values2) {\n    if (values1 === void 0) {\n      values1 = {};\n    }\n\n    if (values2 === void 0) {\n      values2 = {};\n    }\n\n    return params.filter(function (param) {\n      return !param.type.equals(values1[param.id], values2[param.id]);\n    });\n  };\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n\n\n  Param.equals = function (params, values1, values2) {\n    if (values1 === void 0) {\n      values1 = {};\n    }\n\n    if (values2 === void 0) {\n      values2 = {};\n    }\n\n    return Param.changed(params, values1, values2).length === 0;\n  };\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n\n\n  Param.validates = function (params, values) {\n    if (values === void 0) {\n      values = {};\n    }\n\n    return params.map(function (param) {\n      return param.validates(values[param.id]);\n    }).reduce(allTrueR, true);\n  };\n\n  Param.prototype.isDefaultValue = function (value) {\n    return this.isOptional && this.type.equals(this.value(), value);\n  };\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n\n\n  Param.prototype.value = function (value) {\n    var _this = this;\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n\n\n    var getDefaultValue = function () {\n      if (_this._defaultValueCache) return _this._defaultValueCache.defaultValue;\n      if (!services.$injector) throw new Error('Injectable functions cannot be called at configuration time');\n      var defaultValue = services.$injector.invoke(_this.config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue)) throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\n      if (_this.config.$$fn['__cacheable']) {\n        _this._defaultValueCache = {\n          defaultValue: defaultValue\n        };\n      }\n\n      return defaultValue;\n    };\n\n    var replaceSpecialValues = function (val) {\n      for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n        var tuple = _a[_i];\n        if (tuple.from === val) return tuple.to;\n      }\n\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  };\n\n  Param.prototype.isSearch = function () {\n    return this.location === DefType.SEARCH;\n  };\n\n  Param.prototype.validates = function (value) {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true; // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\n    var normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false; // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\n    var encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(encoded));\n  };\n\n  Param.prototype.toString = function () {\n    return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n  };\n\n  return Param;\n}();\n\nexport { Param };","map":{"version":3,"mappings":"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","names":["extend","filter","map","allTrueR","find","prop","isInjectable","isDefined","isString","isArray","isUndefined","services","ParamType","hasOwn","Object","prototype","hasOwnProperty","isShorthand","cfg","bind","length","DefType","getParamDeclaration","paramName","location","state","noReloadOnSearch","reloadOnSearch","SEARCH","undefined","dynamic","defaultConfig","paramConfig","unwrapShorthand","params","value","getStaticDefaultValue","$$fn","getType","urlType","id","paramTypes","type","name","Error","CONFIG","PATH","getSquashPolicy","config","isOptional","defaultPolicy","squash","getReplace","arrayMode","from","to","replace","push","configuredKeys","item","indexOf","concat","urlConfig","getArrayMode","$asArray","raw","defaultSquashPolicy","inherit","arrayDefaults","array","arrayParamNomenclature","match","Param","values","paramValues","_i","param","values1","values2","equals","changed","validates","reduce","getDefaultValue","_this","_defaultValueCache","defaultValue","$injector","invoke","is","replaceSpecialValues","val","tuple","$normalize","normalized","encoded","encode","pattern","exec"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\params\\@uirouter\\core\\params\\param.ts"],"sourcesContent":["import { extend, filter, map, allTrueR, find } from '../common/common';\nimport { prop } from '../common/hof';\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from '../common/predicates';\nimport { RawParams, ParamDeclaration } from '../params/interface';\nimport { services } from '../common/coreservices';\nimport { ParamType } from './paramType';\nimport { ParamTypes } from './paramTypes';\nimport { StateDeclaration } from '../state';\nimport { UrlConfig } from '../url';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nconst isShorthand = (cfg: ParamDeclaration) =>\n  ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n\nenum DefType {\n  PATH,\n  SEARCH,\n  CONFIG,\n}\nexport { DefType };\n\nfunction getParamDeclaration(paramName: string, location: DefType, state: StateDeclaration): ParamDeclaration {\n  const noReloadOnSearch = (state.reloadOnSearch === false && location === DefType.SEARCH) || undefined;\n  const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n  const defaultConfig = isDefined(dynamic) ? { dynamic } : {};\n  const paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);\n  return extend(defaultConfig, paramConfig);\n}\n\nfunction unwrapShorthand(cfg: ParamDeclaration): ParamDeclaration {\n  cfg = isShorthand(cfg) ? ({ value: cfg } as ParamDeclaration) : cfg;\n\n  getStaticDefaultValue['__cacheable'] = true;\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n  return extend(cfg, { $$fn });\n}\n\nfunction getType(cfg: ParamDeclaration, urlType: ParamType, location: DefType, id: string, paramTypes: ParamTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(`Param '${id}' has two type configurations.`);\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type as string))\n    return paramTypes.type(cfg.type as string);\n  if (urlType) return urlType;\n  if (!cfg.type) {\n    const type =\n      location === DefType.CONFIG\n        ? 'any'\n        : location === DefType.PATH\n        ? 'path'\n        : location === DefType.SEARCH\n        ? 'query'\n        : 'string';\n    return paramTypes.type(type);\n  }\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type as string);\n}\n\n/** returns false, true, or the squash value to indicate the \"default parameter url squash policy\". */\nfunction getSquashPolicy(config: ParamDeclaration, isOptional: boolean, defaultPolicy: boolean | string) {\n  const squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(`Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`);\n}\n\nfunction getReplace(config: ParamDeclaration, arrayMode: boolean, isOptional: boolean, squash: string | boolean) {\n  const defaultPolicy = [\n    { from: '', to: isOptional || arrayMode ? undefined : '' },\n    { from: null, to: isOptional || arrayMode ? undefined : '' },\n  ];\n\n  const replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({ from: squash, to: undefined });\n\n  const configuredKeys = map(replace, prop('from'));\n  return filter(defaultPolicy, (item) => configuredKeys.indexOf(item.from) === -1).concat(replace);\n}\n\nexport class Param {\n  id: string;\n  type: ParamType;\n  location: DefType;\n  isOptional: boolean;\n  dynamic: boolean;\n  raw: boolean;\n  squash: boolean | string;\n  replace: [{ to: any; from: any }];\n  inherit: boolean;\n  array: boolean;\n  config: any;\n  /** Cache the default value if it is a static value */\n  _defaultValueCache: {\n    defaultValue: any;\n  };\n\n  static values(params: Param[], values: RawParams = {}): RawParams {\n    const paramValues = {} as RawParams;\n    for (const param of params) {\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n    return paramValues;\n  }\n\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n  static changed(params: Param[], values1: RawParams = {}, values2: RawParams = {}): Param[] {\n    return params.filter((param) => !param.type.equals(values1[param.id], values2[param.id]));\n  }\n\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n  static equals(params: Param[], values1 = {}, values2 = {}): boolean {\n    return Param.changed(params, values1, values2).length === 0;\n  }\n\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n  static validates(params: Param[], values: RawParams = {}): boolean {\n    return params.map((param) => param.validates(values[param.id])).reduce(allTrueR, true);\n  }\n\n  constructor(id: string, type: ParamType, location: DefType, urlConfig: UrlConfig, state: StateDeclaration) {\n    const config: ParamDeclaration = getParamDeclaration(id, location, state);\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    const arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    const isOptional = config.value !== undefined || location === DefType.SEARCH;\n    const dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    const squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());\n    const replace = getReplace(config, arrayMode, isOptional, squash);\n    const inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      const arrayDefaults = { array: location === DefType.SEARCH ? 'auto' : false };\n      const arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, { id, type, location, isOptional, dynamic, raw, squash, replace, inherit, array: arrayMode, config });\n  }\n\n  isDefaultValue(value: any): boolean {\n    return this.isOptional && this.type.equals(this.value(), value);\n  }\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  value(value?: any): any {\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    const getDefaultValue = () => {\n      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;\n\n      if (!services.$injector) throw new Error('Injectable functions cannot be called at configuration time');\n\n      const defaultValue = services.$injector.invoke(this.config.$$fn);\n\n      if (defaultValue !== null && defaultValue !== undefined && !this.type.is(defaultValue))\n        throw new Error(\n          `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`\n        );\n\n      if (this.config.$$fn['__cacheable']) {\n        this._defaultValueCache = { defaultValue };\n      }\n\n      return defaultValue;\n    };\n\n    const replaceSpecialValues = (val: any) => {\n      for (const tuple of this.replace) {\n        if (tuple.from === val) return tuple.to;\n      }\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  }\n\n  isSearch(): boolean {\n    return this.location === DefType.SEARCH;\n  }\n\n  validates(value: any): boolean {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true;\n\n    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n    const normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false;\n\n    // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n    const encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(<string>encoded));\n  }\n\n  toString() {\n    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}