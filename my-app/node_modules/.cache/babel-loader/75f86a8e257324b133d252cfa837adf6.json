{"ast":null,"code":"import { isString, isFunction, Glob, extend, removeFrom, tail, values, identity, mapObj } from '../common';\nimport { // has or is using\nTransitionHookScope } from './interface';\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @internal\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\n\nexport function matchState(state, criterion, transition) {\n  var toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state) {\n    var globStrings = toMatch;\n\n    for (var i = 0; i < globStrings.length; i++) {\n      var glob = new Glob(globStrings[i]);\n\n      if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var matchFn = isFunction(toMatch) ? toMatch : matchGlobs;\n  return !!matchFn(state, transition);\n}\n/**\n * The registration data for a registered transition hook\n */\n\nvar RegisteredHook =\n/** @class */\nfunction () {\n  function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.tranSvc = tranSvc;\n    this.eventType = eventType;\n    this.callback = callback;\n    this.matchCriteria = matchCriteria;\n    this.removeHookFromRegistry = removeHookFromRegistry;\n    this.invokeCount = 0;\n    this._deregistered = false;\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n\n\n  RegisteredHook.prototype._matchingNodes = function (nodes, criterion, transition) {\n    if (criterion === true) return nodes;\n    var matching = nodes.filter(function (node) {\n      return matchState(node.state, criterion, transition);\n    });\n    return matching.length ? matching : null;\n  };\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n\n\n  RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n    return mapObj(this.tranSvc._pluginapi._getPathTypes(), function () {\n      return true;\n    });\n  };\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n\n\n  RegisteredHook.prototype._getMatchingNodes = function (treeChanges, transition) {\n    var _this = this;\n\n    var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    var paths = values(this.tranSvc._pluginapi._getPathTypes());\n    return paths.reduce(function (mn, pathtype) {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      var isStateHook = pathtype.scope === TransitionHookScope.STATE;\n      var path = treeChanges[pathtype.name] || [];\n      var nodes = isStateHook ? path : [tail(path)];\n      mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name], transition);\n      return mn;\n    }, {});\n  };\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n\n\n  RegisteredHook.prototype.matches = function (treeChanges, transition) {\n    var matches = this._getMatchingNodes(treeChanges, transition); // Check if all the criteria matched the TreeChanges object\n\n\n    var allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  };\n\n  RegisteredHook.prototype.deregister = function () {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  };\n\n  return RegisteredHook;\n}();\n\nexport { RegisteredHook };\n/** Return a registration function of the requested type. */\n\nexport function makeEvent(registry, transitionService, eventType) {\n  // Create the object which holds the registered transition hooks.\n  var _registeredHooks = registry._registeredHooks = registry._registeredHooks || {};\n\n  var hooks = _registeredHooks[eventType.name] = [];\n  var removeHookFn = removeFrom(hooks); // Create hook registration function on the IHookRegistry for the event\n\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}","map":{"version":3,"mappings":"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","names":["isString","isFunction","Glob","extend","removeFrom","tail","values","identity","mapObj","TransitionHookScope","matchState","state","criterion","transition","toMatch","matchGlobs","_state","globStrings","i","length","glob","matches","name","matchFn","tranSvc","eventType","callback","matchCriteria","removeHookFromRegistry","options","priority","bind","invokeLimit","RegisteredHook","nodes","matching","filter","node","_pluginapi","_getPathTypes","treeChanges","criteria","_getDefaultMatchCriteria","paths","reduce","mn","pathtype","isStateHook","scope","STATE","path","_this","_matchingNodes","_getMatchingNodes","allMatched","every","_deregistered","makeEvent","registry","transitionService","_registeredHooks","hooks","removeHookFn","hookRegistrationFn","matchObject","registeredHook","push","deregister"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\transition\\@uirouter\\core\\transition\\hookRegistry.ts"],"sourcesContent":["import { isString, isFunction, Glob, extend, removeFrom, tail, values, identity, mapObj } from '../common';\nimport { PathNode } from '../path/pathNode';\nimport {\n  TransitionStateHookFn,\n  TransitionHookFn,\n  TransitionHookPhase, // has or is using\n  TransitionHookScope,\n  IHookRegistry,\n  PathType,\n} from './interface';\n\nimport {\n  HookRegOptions,\n  HookMatchCriteria,\n  TreeChanges,\n  HookMatchCriterion,\n  IMatchingNodes,\n  HookFn,\n} from './interface';\nimport { Transition } from './transition';\nimport { StateObject } from '../state/stateObject';\nimport { TransitionEventType } from './transitionEventType';\nimport { TransitionService } from './transitionService';\n\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @internal\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nexport function matchState(state: StateObject, criterion: HookMatchCriterion, transition: Transition) {\n  const toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state: StateObject) {\n    const globStrings = <string[]>toMatch;\n    for (let i = 0; i < globStrings.length; i++) {\n      const glob = new Glob(globStrings[i]);\n\n      if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const matchFn = <any>(isFunction(toMatch) ? toMatch : matchGlobs);\n  return !!matchFn(state, transition);\n}\n\n/**\n * The registration data for a registered transition hook\n */\nexport class RegisteredHook {\n  priority: number;\n  bind: any;\n  invokeCount = 0;\n  invokeLimit: number;\n  _deregistered = false;\n\n  constructor(\n    public tranSvc: TransitionService,\n    public eventType: TransitionEventType,\n    public callback: HookFn,\n    public matchCriteria: HookMatchCriteria,\n    public removeHookFromRegistry: (hook: RegisteredHook) => void,\n    options: HookRegOptions = {} as any\n  ) {\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n  private _matchingNodes(nodes: PathNode[], criterion: HookMatchCriterion, transition: Transition): PathNode[] {\n    if (criterion === true) return nodes;\n    const matching = nodes.filter((node) => matchState(node.state, criterion, transition));\n    return matching.length ? matching : null;\n  }\n\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n  private _getDefaultMatchCriteria(): HookMatchCriteria {\n    return mapObj(this.tranSvc._pluginapi._getPathTypes(), () => true);\n  }\n\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n  private _getMatchingNodes(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    const paths: PathType[] = values(this.tranSvc._pluginapi._getPathTypes());\n\n    return paths.reduce((mn: IMatchingNodes, pathtype: PathType) => {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      const isStateHook = pathtype.scope === TransitionHookScope.STATE;\n      const path = treeChanges[pathtype.name] || [];\n      const nodes: PathNode[] = isStateHook ? path : [tail(path)];\n\n      mn[pathtype.name] = this._matchingNodes(nodes, criteria[pathtype.name], transition);\n      return mn;\n    }, {} as IMatchingNodes);\n  }\n\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n  matches(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const matches = this._getMatchingNodes(treeChanges, transition);\n\n    // Check if all the criteria matched the TreeChanges object\n    const allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  }\n\n  deregister() {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  }\n}\n\n/** Return a registration function of the requested type. */\nexport function makeEvent(\n  registry: IHookRegistry,\n  transitionService: TransitionService,\n  eventType: TransitionEventType\n) {\n  // Create the object which holds the registered transition hooks.\n  const _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});\n  const hooks = (_registeredHooks[eventType.name] = []);\n  const removeHookFn: (hook: RegisteredHook) => void = removeFrom(hooks);\n\n  // Create hook registration function on the IHookRegistry for the event\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options = {}) {\n    const registeredHook = new RegisteredHook(\n      transitionService,\n      eventType,\n      callback,\n      matchObject,\n      removeHookFn,\n      options\n    );\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}\n"]},"metadata":{},"sourceType":"module"}