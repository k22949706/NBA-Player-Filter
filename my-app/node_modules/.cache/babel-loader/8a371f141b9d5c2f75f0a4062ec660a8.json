{"ast":null,"code":"import { noop } from '../common/common';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { val } from '../common/hof';\nexport var RESOLVE_HOOK_PRIORITY = 1000;\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar eagerResolvePath = function (trans) {\n  return new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);\n};\n\nexport var registerEagerResolvePath = function (transitionService) {\n  return transitionService.onStart({}, eagerResolvePath, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar lazyResolveState = function (trans, state) {\n  return new ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath('LAZY', trans).then(noop);\n};\n\nexport var registerLazyResolveState = function (transitionService) {\n  return transitionService.onEnter({\n    entering: val(true)\n  }, lazyResolveState, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar resolveRemaining = function (trans) {\n  return new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);\n};\n\nexport var registerResolveRemaining = function (transitionService) {\n  return transitionService.onFinish({}, resolveRemaining, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAqB,kBAArB;AAEA,SAASC,cAAT,QAA+B,2BAA/B;AAGA,SAASC,GAAT,QAAoB,eAApB;AAGA,OAAO,IAAMC,qBAAqB,GAAG,IAA9B;AAEP;;;;;;;;;;AASA,IAAMC,gBAAgB,GAAqB,UAACC,KAAD,EAAkB;EAC3D,WAAIJ,cAAJ,CAAmBI,KAAK,CAACC,WAAN,GAAoBC,EAAvC,EAA2CC,WAA3C,CAAuD,OAAvD,EAAgEH,KAAhE,EAAuEI,IAAvE,CAA4ET,IAA5E;AAAiF,CADnF;;AAGA,OAAO,IAAMU,wBAAwB,GAAG,UAACC,iBAAD,EAAqC;EAC3E,wBAAiB,CAACC,OAAlB,CAA0B,EAA1B,EAA8BR,gBAA9B,EAAgD;IAAES,QAAQ,EAAEV;EAAZ,CAAhD;AAAoF,CAD/E;AAGP;;;;;;;;;;AASA,IAAMW,gBAAgB,GAA0B,UAACT,KAAD,EAAoBU,KAApB,EAA2C;EACzF,WAAId,cAAJ,CAAmBI,KAAK,CAACC,WAAN,GAAoBC,EAAvC,EAA2CS,UAA3C,CAAsDD,KAAK,CAACE,OAAN,EAAtD,EAAuET,WAAvE,CAAmF,MAAnF,EAA2FH,KAA3F,EAAkGI,IAAlG,CAAuGT,IAAvG;AAA4G,CAD9G;;AAGA,OAAO,IAAMkB,wBAAwB,GAAG,UAACP,iBAAD,EAAqC;EAC3E,wBAAiB,CAACQ,OAAlB,CAA0B;IAAEC,QAAQ,EAAElB,GAAG,CAAC,IAAD;EAAf,CAA1B,EAAmDY,gBAAnD,EAAqE;IAAED,QAAQ,EAAEV;EAAZ,CAArE;AAAyG,CADpG;AAGP;;;;;;;;;;;AAUA,IAAMkB,gBAAgB,GAAqB,UAAChB,KAAD,EAAkB;EAC3D,WAAIJ,cAAJ,CAAmBI,KAAK,CAACC,WAAN,GAAoBC,EAAvC,EAA2CC,WAA3C,CAAuD,MAAvD,EAA+DH,KAA/D,EAAsEI,IAAtE,CAA2ET,IAA3E;AAAgF,CADlF;;AAGA,OAAO,IAAMsB,wBAAwB,GAAG,UAACX,iBAAD,EAAqC;EAC3E,wBAAiB,CAACY,QAAlB,CAA2B,EAA3B,EAA+BF,gBAA/B,EAAiD;IAAER,QAAQ,EAAEV;EAAZ,CAAjD;AAAqF,CADhF","names":["noop","ResolveContext","val","RESOLVE_HOOK_PRIORITY","eagerResolvePath","trans","treeChanges","to","resolvePath","then","registerEagerResolvePath","transitionService","onStart","priority","lazyResolveState","state","subContext","$$state","registerLazyResolveState","onEnter","entering","resolveRemaining","registerResolveRemaining","onFinish"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\hooks\\@uirouter\\core\\hooks\\resolve.ts"],"sourcesContent":["import { noop } from '../common/common';\nimport { Transition } from '../transition/transition';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { TransitionStateHookFn, TransitionHookFn } from '../transition/interface';\nimport { TransitionService } from '../transition/transitionService';\nimport { val } from '../common/hof';\nimport { StateDeclaration } from '../state/interface';\n\nexport const RESOLVE_HOOK_PRIORITY = 1000;\n\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst eagerResolvePath: TransitionHookFn = (trans: Transition) =>\n  new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);\n\nexport const registerEagerResolvePath = (transitionService: TransitionService) =>\n  transitionService.onStart({}, eagerResolvePath, { priority: RESOLVE_HOOK_PRIORITY });\n\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst lazyResolveState: TransitionStateHookFn = (trans: Transition, state: StateDeclaration) =>\n  new ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath('LAZY', trans).then(noop);\n\nexport const registerLazyResolveState = (transitionService: TransitionService) =>\n  transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: RESOLVE_HOOK_PRIORITY });\n\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\nconst resolveRemaining: TransitionHookFn = (trans: Transition) =>\n  new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);\n\nexport const registerResolveRemaining = (transitionService: TransitionService) =>\n  transitionService.onFinish({}, resolveRemaining, { priority: RESOLVE_HOOK_PRIORITY });\n"]},"metadata":{},"sourceType":"module"}