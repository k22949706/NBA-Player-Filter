{"ast":null,"code":"import { extend, find, pick, omit, tail, mergeR, values, unnestR, inArray, arrayTuples } from '../common/common';\nimport { prop, propEq } from '../common/hof';\nimport { TargetState } from '../state/targetState';\nimport { PathNode } from './pathNode';\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\n\nvar PathUtils =\n/** @class */\nfunction () {\n  function PathUtils() {}\n  /** Given a PathNode[], create an TargetState */\n\n\n  PathUtils.makeTargetState = function (registry, path) {\n    var state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});\n  };\n\n  PathUtils.buildPath = function (targetState) {\n    var toParams = targetState.params();\n    return targetState.$state().path.map(function (state) {\n      return new PathNode(state).applyRawParams(toParams);\n    });\n  };\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\n\n  PathUtils.buildToPath = function (fromPath, targetState) {\n    var toPath = PathUtils.buildPath(targetState);\n\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n\n    return toPath;\n  };\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n\n\n  PathUtils.applyViewConfigs = function ($view, path, states) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path.filter(function (node) {\n      return inArray(states, node.state);\n    }).forEach(function (node) {\n      var viewDecls = values(node.state.views || {});\n      var subPath = PathUtils.subPath(path, function (n) {\n        return n === node;\n      });\n      var viewConfigs = viewDecls.map(function (view) {\n        return $view.createViewConfig(subPath, view);\n      });\n      node.views = viewConfigs.reduce(unnestR, []);\n    });\n  };\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n\n\n  PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n    if (toKeys === void 0) {\n      toKeys = [];\n    }\n\n    function nodeParamVals(path, state) {\n      var node = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    var noInherit = fromPath.map(function (node) {\n      return node.paramSchema;\n    }).reduce(unnestR, []).filter(function (param) {\n      return !param.inherit;\n    }).map(prop('id'));\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n\n    function makeInheritedParamsNode(toNode) {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      var toParamVals = extend({}, toNode && toNode.paramValues); // limited to only those keys found in toParams\n\n      var incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit); // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\n      var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    } // The param keys specified by the incoming toParams\n\n\n    return toPath.map(makeInheritedParamsNode);\n  };\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n\n\n  PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n    var max = Math.min(fromPath.length, toPath.length);\n    var keep = 0;\n\n    var nodesMatch = function (node1, node2) {\n      return node1.equals(node2, PathUtils.nonDynamicParams);\n    };\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n    /** Given a retained node, return a new node which uses the to node's param values */\n\n\n    function applyToParams(retainedNode, idx) {\n      var cloned = retainedNode.clone();\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    var from, retained, exiting, entering, to;\n    from = fromPath;\n    retained = from.slice(0, keep);\n    exiting = from.slice(keep); // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\n    var retainedWithToParams = retained.map(applyToParams);\n    entering = toPath.slice(keep);\n    to = retainedWithToParams.concat(entering);\n    return {\n      from: from,\n      to: to,\n      retained: retained,\n      retainedWithToParams: retainedWithToParams,\n      exiting: exiting,\n      entering: entering\n    };\n  };\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n\n\n  PathUtils.matching = function (pathA, pathB, paramsFn) {\n    var done = false;\n    var tuples = arrayTuples(pathA, pathB);\n    return tuples.reduce(function (matching, _a) {\n      var nodeA = _a[0],\n          nodeB = _a[1];\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  };\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n\n\n  PathUtils.equals = function (pathA, pathB, paramsFn) {\n    return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  };\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n\n\n  PathUtils.subPath = function (path, predicate) {\n    var node = find(path, predicate);\n    var elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  };\n\n  PathUtils.nonDynamicParams = function (node) {\n    return node.state.parameters({\n      inherit: false\n    }).filter(function (param) {\n      return !param.dynamic;\n    });\n  };\n  /** Gets the raw parameter values from a path */\n\n\n  PathUtils.paramValues = function (path) {\n    return path.reduce(function (acc, node) {\n      return extend(acc, node.paramValues);\n    }, {});\n  };\n\n  return PathUtils;\n}();\n\nexport { PathUtils };","map":{"version":3,"mappings":"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","names":["extend","find","pick","omit","tail","mergeR","values","unnestR","inArray","arrayTuples","prop","propEq","TargetState","PathNode","PathUtils","registry","path","state","map","reduce","targetState","toParams","params","$state","applyRawParams","fromPath","toPath","buildPath","options","inherit","inheritParams","Object","keys","$view","states","filter","node","forEach","viewDecls","views","subPath","n","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","paramValues","noInherit","paramSchema","param","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","ownParamVals","reloadState","max","Math","min","length","keep","nodesMatch","node1","node2","equals","nonDynamicParams","applyToParams","retainedNode","idx","cloned","clone","from","retained","exiting","entering","to","slice","retainedWithToParams","concat","pathA","pathB","paramsFn","done","tuples","matching","_a","nodeA","nodeB","predicate","elementIdx","indexOf","undefined","parameters","dynamic","acc"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\path\\@uirouter\\core\\path\\pathUtils.ts"],"sourcesContent":["import {\n  extend,\n  find,\n  pick,\n  omit,\n  tail,\n  mergeR,\n  values,\n  unnestR,\n  Predicate,\n  inArray,\n  arrayTuples,\n} from '../common/common';\nimport { prop, propEq, not } from '../common/hof';\n\nimport { RawParams } from '../params/interface';\nimport { TreeChanges } from '../transition/interface';\nimport { ViewConfig } from '../view/interface';\nimport { _ViewDeclaration } from '../state/interface';\n\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { GetParamsFn, PathNode } from './pathNode';\nimport { ViewService } from '../view/view';\nimport { Param } from '../params/param';\nimport { StateRegistry } from '../state';\n\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nexport class PathUtils {\n  /** Given a PathNode[], create an TargetState */\n  static makeTargetState(registry: StateRegistry, path: PathNode[]): TargetState {\n    const state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});\n  }\n\n  static buildPath(targetState: TargetState) {\n    const toParams = targetState.params();\n    return targetState.$state().path.map((state) => new PathNode(state).applyRawParams(toParams));\n  }\n\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n  static buildToPath(fromPath: PathNode[], targetState: TargetState): PathNode[] {\n    const toPath: PathNode[] = PathUtils.buildPath(targetState);\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n    return toPath;\n  }\n\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n  static applyViewConfigs($view: ViewService, path: PathNode[], states: StateObject[]) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path\n      .filter((node) => inArray(states, node.state))\n      .forEach((node) => {\n        const viewDecls: _ViewDeclaration[] = values(node.state.views || {});\n        const subPath = PathUtils.subPath(path, (n) => n === node);\n        const viewConfigs: ViewConfig[][] = viewDecls.map((view) => $view.createViewConfig(subPath, view));\n        node.views = viewConfigs.reduce(unnestR, []);\n      });\n  }\n\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n  static inheritParams(fromPath: PathNode[], toPath: PathNode[], toKeys: string[] = []): PathNode[] {\n    function nodeParamVals(path: PathNode[], state: StateObject): RawParams {\n      const node: PathNode = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    const noInherit = fromPath\n      .map((node) => node.paramSchema)\n      .reduce(unnestR, [])\n      .filter((param) => !param.inherit)\n      .map(prop('id'));\n\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n    function makeInheritedParamsNode(toNode: PathNode): PathNode {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      let toParamVals = extend({}, toNode && toNode.paramValues);\n      // limited to only those keys found in toParams\n      const incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      const fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n      const ownParamVals: RawParams = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    }\n\n    // The param keys specified by the incoming toParams\n    return <PathNode[]>toPath.map(makeInheritedParamsNode);\n  }\n\n  static nonDynamicParams = (node: PathNode): Param[] =>\n    node.state.parameters({ inherit: false }).filter((param) => !param.dynamic);\n\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n  static treeChanges(fromPath: PathNode[], toPath: PathNode[], reloadState: StateObject): TreeChanges {\n    const max = Math.min(fromPath.length, toPath.length);\n    let keep = 0;\n\n    const nodesMatch = (node1: PathNode, node2: PathNode) => node1.equals(node2, PathUtils.nonDynamicParams);\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n\n    /** Given a retained node, return a new node which uses the to node's param values */\n    function applyToParams(retainedNode: PathNode, idx: number): PathNode {\n      const cloned = retainedNode.clone();\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    let from: PathNode[], retained: PathNode[], exiting: PathNode[], entering: PathNode[], to: PathNode[];\n\n    from = fromPath;\n    retained = from.slice(0, keep);\n    exiting = from.slice(keep);\n\n    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n    const retainedWithToParams = retained.map(applyToParams);\n    entering = toPath.slice(keep);\n    to = retainedWithToParams.concat(entering);\n\n    return { from, to, retained, retainedWithToParams, exiting, entering };\n  }\n\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n  static matching(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): PathNode[] {\n    let done = false;\n    const tuples: PathNode[][] = arrayTuples(pathA, pathB);\n    return tuples.reduce((matching, [nodeA, nodeB]) => {\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  }\n\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n  static equals(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): boolean {\n    return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  }\n\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n  static subPath(path: PathNode[], predicate: Predicate<PathNode>): PathNode[] {\n    const node = find(path, predicate);\n    const elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  }\n\n  /** Gets the raw parameter values from a path */\n  static paramValues = (path: PathNode[]) => path.reduce((acc, node) => extend(acc, node.paramValues), {});\n}\n"]},"metadata":{},"sourceType":"module"}