{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { extend, forEach, isDefined, isFunction, isObject } from '../common';\nimport { UrlMatcher } from './urlMatcher';\nimport { DefType, Param } from '../params';\n\nvar ParamFactory =\n/** @class */\nfunction () {\n  function ParamFactory(router) {\n    this.router = router;\n  }\n\n  ParamFactory.prototype.fromConfig = function (id, type, state) {\n    return new Param(id, type, DefType.CONFIG, this.router.urlService.config, state);\n  };\n\n  ParamFactory.prototype.fromPath = function (id, type, state) {\n    return new Param(id, type, DefType.PATH, this.router.urlService.config, state);\n  };\n\n  ParamFactory.prototype.fromSearch = function (id, type, state) {\n    return new Param(id, type, DefType.SEARCH, this.router.urlService.config, state);\n  };\n\n  return ParamFactory;\n}();\n\nexport { ParamFactory };\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\n\nvar UrlMatcherFactory =\n/** @class */\nfunction () {\n  // TODO: move implementations to UrlConfig (urlService.config)\n  function UrlMatcherFactory(\n  /** @internal */\n  router) {\n    var _this = this;\n\n    this.router = router;\n    /** Creates a new [[Param]] for a given location (DefType) */\n\n    this.paramFactory = new ParamFactory(this.router); // TODO: Check if removal of this will break anything, then remove these\n\n    this.UrlMatcher = UrlMatcher;\n    this.Param = Param;\n    /** @deprecated use [[UrlConfig.caseInsensitive]] */\n\n    this.caseInsensitive = function (value) {\n      return _this.router.urlService.config.caseInsensitive(value);\n    };\n    /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */\n\n\n    this.defaultSquashPolicy = function (value) {\n      return _this.router.urlService.config.defaultSquashPolicy(value);\n    };\n    /** @deprecated use [[UrlConfig.strictMode]] */\n\n\n    this.strictMode = function (value) {\n      return _this.router.urlService.config.strictMode(value);\n    };\n    /** @deprecated use [[UrlConfig.type]] */\n\n\n    this.type = function (name, definition, definitionFn) {\n      return _this.router.urlService.config.type(name, definition, definitionFn) || _this;\n    };\n  }\n  /**\n   * Creates a [[UrlMatcher]] for the specified pattern.\n   *\n   * @param pattern  The URL pattern.\n   * @param config  The config object hash.\n   * @returns The UrlMatcher.\n   */\n\n\n  UrlMatcherFactory.prototype.compile = function (pattern, config) {\n    var urlConfig = this.router.urlService.config; // backward-compatible support for config.params -> config.state.params\n\n    var params = config && !config.state && config.params;\n    config = params ? __assign({\n      state: {\n        params: params\n      }\n    }, config) : config;\n    var globalConfig = {\n      strict: urlConfig._isStrictMode,\n      caseInsensitive: urlConfig._isCaseInsensitive,\n      decodeParams: urlConfig._decodeParams\n    };\n    return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));\n  };\n  /**\n   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n   *\n   * @param object  The object to perform the type check against.\n   * @returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n\n\n  UrlMatcherFactory.prototype.isMatcher = function (object) {\n    // TODO: typeof?\n    if (!isObject(object)) return false;\n    var result = true;\n    forEach(UrlMatcher.prototype, function (val, name) {\n      if (isFunction(val)) result = result && isDefined(object[name]) && isFunction(object[name]);\n    });\n    return result;\n  };\n  /** @internal */\n\n\n  UrlMatcherFactory.prototype.$get = function () {\n    var urlConfig = this.router.urlService.config;\n    urlConfig.paramTypes.enqueue = false;\n\n    urlConfig.paramTypes._flushTypeQueue();\n\n    return this;\n  };\n\n  return UrlMatcherFactory;\n}();\n\nexport { UrlMatcherFactory };","map":{"version":3,"mappings":"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","names":["extend","forEach","isDefined","isFunction","isObject","UrlMatcher","DefType","Param","router","ParamFactory","id","type","state","CONFIG","urlService","config","PATH","SEARCH","value","caseInsensitive","defaultSquashPolicy","strictMode","name","definition","definitionFn","_this","UrlMatcherFactory","pattern","urlConfig","params","__assign","globalConfig","strict","_isStrictMode","_isCaseInsensitive","decodeParams","_decodeParams","paramTypes","paramFactory","object","result","prototype","val","enqueue","_flushTypeQueue"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\url\\@uirouter\\core\\url\\urlMatcherFactory.ts"],"sourcesContent":["import { extend, forEach, isDefined, isFunction, isObject } from '../common';\nimport { UrlMatcher } from './urlMatcher';\nimport { DefType, Param, ParamType, ParamTypeDefinition } from '../params';\nimport { UrlMatcherCompileConfig } from './interface';\nimport { StateDeclaration } from '../state';\nimport { UIRouter } from '../router';\n\nexport class ParamFactory {\n  fromConfig(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.CONFIG, this.router.urlService.config, state);\n  }\n\n  fromPath(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.PATH, this.router.urlService.config, state);\n  }\n\n  fromSearch(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.SEARCH, this.router.urlService.config, state);\n  }\n\n  constructor(private router: UIRouter) {}\n}\n\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nexport class UrlMatcherFactory {\n  /** Creates a new [[Param]] for a given location (DefType) */\n  paramFactory = new ParamFactory(this.router);\n  // TODO: Check if removal of this will break anything, then remove these\n  UrlMatcher: typeof UrlMatcher = UrlMatcher;\n  Param: typeof Param = Param;\n\n  // TODO: move implementations to UrlConfig (urlService.config)\n  constructor(/** @internal */ private router: UIRouter) {}\n\n  /**\n   * Creates a [[UrlMatcher]] for the specified pattern.\n   *\n   * @param pattern  The URL pattern.\n   * @param config  The config object hash.\n   * @returns The UrlMatcher.\n   */\n  compile(pattern: string, config?: UrlMatcherCompileConfig) {\n    const urlConfig = this.router.urlService.config;\n    // backward-compatible support for config.params -> config.state.params\n    const params = config && !config.state && (config as any).params;\n    config = params ? { state: { params }, ...config } : config;\n    const globalConfig: UrlMatcherCompileConfig = {\n      strict: urlConfig._isStrictMode,\n      caseInsensitive: urlConfig._isCaseInsensitive,\n      decodeParams: urlConfig._decodeParams,\n    };\n    return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));\n  }\n\n  /**\n   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n   *\n   * @param object  The object to perform the type check against.\n   * @returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  isMatcher(object: any): boolean {\n    // TODO: typeof?\n    if (!isObject(object)) return false;\n    let result = true;\n\n    forEach(UrlMatcher.prototype, (val, name) => {\n      if (isFunction(val)) result = result && isDefined(object[name]) && isFunction(object[name]);\n    });\n    return result;\n  }\n\n  /** @internal */\n  $get() {\n    const urlConfig = this.router.urlService.config;\n    urlConfig.paramTypes.enqueue = false;\n    urlConfig.paramTypes._flushTypeQueue();\n    return this;\n  }\n\n  /** @deprecated use [[UrlConfig.caseInsensitive]] */\n  caseInsensitive = (value?: boolean) => this.router.urlService.config.caseInsensitive(value);\n\n  /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */\n  defaultSquashPolicy = (value?: boolean | string) => this.router.urlService.config.defaultSquashPolicy(value);\n\n  /** @deprecated use [[UrlConfig.strictMode]] */\n  strictMode = (value?: boolean) => this.router.urlService.config.strictMode(value);\n\n  /** @deprecated use [[UrlConfig.type]] */\n  type = (name: string, definition?: ParamTypeDefinition, definitionFn?: () => ParamTypeDefinition) => {\n    return this.router.urlService.config.type(name, definition, definitionFn) || this;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}