{"ast":null,"code":"import { map, inherit, identity, unnest, tail, find, allTrueR, unnestR, arrayTuples } from '../common/common';\nimport { prop, propEq } from '../common/hof';\nimport { isArray, isString, isDefined } from '../common/predicates';\nimport { Param, DefType } from '../params/param';\nimport { joinNeighborsR, splitOnDelim } from '../common/strings';\nimport { defaults } from '../common';\n\nfunction quoteRegExp(str, param) {\n  var surroundPattern = ['', ''],\n      result = str.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, '\\\\$&');\n  if (!param) return result;\n\n  switch (param.squash) {\n    case false:\n      surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n      break;\n\n    case true:\n      result = result.replace(/\\/$/, '');\n      surroundPattern = ['(?:/(', ')|/)?'];\n      break;\n\n    default:\n      surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n      break;\n  }\n\n  return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n\nvar memoizeTo = function (obj, _prop, fn) {\n  return obj[_prop] = obj[_prop] || fn();\n};\n\nvar splitOnSlash = splitOnDelim('/');\nvar defaultConfig = {\n  state: {\n    params: {}\n  },\n  strict: true,\n  caseInsensitive: true,\n  decodeParams: true\n};\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\n\nvar UrlMatcher =\n/** @class */\nfunction () {\n  /**\n   * @param pattern The pattern to compile into a matcher.\n   * @param paramTypes The [[ParamTypes]] registry\n   * @param paramFactory A [[ParamFactory]] object\n   * @param config  A [[UrlMatcherCompileConfig]] configuration object\n   */\n  function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n    var _this = this;\n    /** @internal */\n\n\n    this._cache = {\n      path: [this]\n    };\n    /** @internal */\n\n    this._children = [];\n    /** @internal */\n\n    this._params = [];\n    /** @internal */\n\n    this._segments = [];\n    /** @internal */\n\n    this._compiled = [];\n    this.config = config = defaults(config, defaultConfig);\n    this.pattern = pattern; // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n    //   '*' name\n    //   ':' name\n    //   '{' name '}'\n    //   '{' name ':' regexp '}'\n    // The regular expression is somewhat complicated due to the need to allow curly braces\n    // inside the regular expression. The placeholder regexp breaks down as follows:\n    //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n    //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n    //    [^{}\\\\]+                       - anything other than curly braces or backslash\n    //    \\\\.                            - a backslash escape\n    //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\n    var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n    var searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n    var patterns = [];\n    var last = 0;\n    var matchArray;\n\n    var checkParamErrors = function (id) {\n      if (!UrlMatcher.nameValidator.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n      if (find(_this._params, propEq('id', id))) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    }; // Split into static segments separated by path parameter placeholders.\n    // The number of segments is always 1 more than the number of parameters.\n\n\n    var matchDetails = function (m, isSearch) {\n      // IE[78] returns '' for unmatched groups instead of null\n      var id = m[2] || m[3];\n      var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n\n      var makeRegexpType = function (str) {\n        return inherit(paramTypes.type(isSearch ? 'query' : 'path'), {\n          pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined)\n        });\n      };\n\n      return {\n        id: id,\n        regexp: regexp,\n        segment: pattern.substring(last, m.index),\n        type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n      };\n    };\n\n    var details;\n    var segment; // tslint:disable-next-line:no-conditional-assignment\n\n    while (matchArray = placeholder.exec(pattern)) {\n      details = matchDetails(matchArray, false);\n      if (details.segment.indexOf('?') >= 0) break; // we're into the search part\n\n      checkParamErrors(details.id);\n\n      this._params.push(paramFactory.fromPath(details.id, details.type, config.state));\n\n      this._segments.push(details.segment);\n\n      patterns.push([details.segment, tail(this._params)]);\n      last = placeholder.lastIndex;\n    }\n\n    segment = pattern.substring(last); // Find any search parameter names and remove them from the last segment\n\n    var i = segment.indexOf('?');\n\n    if (i >= 0) {\n      var search = segment.substring(i);\n      segment = segment.substring(0, i);\n\n      if (search.length > 0) {\n        last = 0; // tslint:disable-next-line:no-conditional-assignment\n\n        while (matchArray = searchPlaceholder.exec(search)) {\n          details = matchDetails(matchArray, true);\n          checkParamErrors(details.id);\n\n          this._params.push(paramFactory.fromSearch(details.id, details.type, config.state));\n\n          last = placeholder.lastIndex; // check if ?&\n        }\n      }\n    }\n\n    this._segments.push(segment);\n\n    this._compiled = patterns.map(function (_pattern) {\n      return quoteRegExp.apply(null, _pattern);\n    }).concat(quoteRegExp(segment));\n  }\n  /** @internal */\n\n\n  UrlMatcher.encodeDashes = function (str) {\n    // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function (c) {\n      return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  };\n  /** @internal Given a matcher, return an array with the matcher's path segments and path params, in order */\n\n\n  UrlMatcher.pathSegmentsAndParams = function (matcher) {\n    var staticSegments = matcher._segments;\n\n    var pathParams = matcher._params.filter(function (p) {\n      return p.location === DefType.PATH;\n    });\n\n    return arrayTuples(staticSegments, pathParams.concat(undefined)).reduce(unnestR, []).filter(function (x) {\n      return x !== '' && isDefined(x);\n    });\n  };\n  /** @internal Given a matcher, return an array with the matcher's query params */\n\n\n  UrlMatcher.queryParams = function (matcher) {\n    return matcher._params.filter(function (p) {\n      return p.location === DefType.SEARCH;\n    });\n  };\n  /**\n   * Compare two UrlMatchers\n   *\n   * This comparison function converts a UrlMatcher into static and dynamic path segments.\n   * Each static path segment is a static string between a path separator (slash character).\n   * Each dynamic segment is a path parameter.\n   *\n   * The comparison function sorts static segments before dynamic ones.\n   */\n\n\n  UrlMatcher.compare = function (a, b) {\n    /**\n     * Turn a UrlMatcher and all its parent matchers into an array\n     * of slash literals '/', string literals, and Param objects\n     *\n     * This example matcher matches strings like \"/foo/:param/tail\":\n     * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n     * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n     *\n     * Caches the result as `matcher._cache.segments`\n     */\n    var segments = function (matcher) {\n      return matcher._cache.segments = matcher._cache.segments || matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).reduce(joinNeighborsR, []).map(function (x) {\n        return isString(x) ? splitOnSlash(x) : x;\n      }).reduce(unnestR, []);\n    };\n    /**\n     * Gets the sort weight for each segment of a UrlMatcher\n     *\n     * Caches the result as `matcher._cache.weights`\n     */\n\n\n    var weights = function (matcher) {\n      return matcher._cache.weights = matcher._cache.weights || segments(matcher).map(function (segment) {\n        // Sort slashes first, then static strings, the Params\n        if (segment === '/') return 1;\n        if (isString(segment)) return 2;\n        if (segment instanceof Param) return 3;\n      });\n    };\n    /**\n     * Pads shorter array in-place (mutates)\n     */\n\n\n    var padArrays = function (l, r, padVal) {\n      var len = Math.max(l.length, r.length);\n\n      while (l.length < len) l.push(padVal);\n\n      while (r.length < len) r.push(padVal);\n    };\n\n    var weightsA = weights(a),\n        weightsB = weights(b);\n    padArrays(weightsA, weightsB, 0);\n\n    var _pairs = arrayTuples(weightsA, weightsB);\n\n    var cmp, i;\n\n    for (i = 0; i < _pairs.length; i++) {\n      cmp = _pairs[i][0] - _pairs[i][1];\n      if (cmp !== 0) return cmp;\n    }\n\n    return 0;\n  };\n  /**\n   * Creates a new concatenated UrlMatcher\n   *\n   * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n   *\n   * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n   */\n\n\n  UrlMatcher.prototype.append = function (url) {\n    this._children.push(url);\n\n    url._cache = {\n      path: this._cache.path.concat(url),\n      parent: this,\n      pattern: null\n    };\n    return url;\n  };\n  /** @internal */\n\n\n  UrlMatcher.prototype.isRoot = function () {\n    return this._cache.path[0] === this;\n  };\n  /** Returns the input pattern string */\n\n\n  UrlMatcher.prototype.toString = function () {\n    return this.pattern;\n  };\n\n  UrlMatcher.prototype._getDecodedParamValue = function (value, param) {\n    if (isDefined(value)) {\n      if (this.config.decodeParams && !param.type.raw) {\n        if (isArray(value)) {\n          value = value.map(function (paramValue) {\n            return decodeURIComponent(paramValue);\n          });\n        } else {\n          value = decodeURIComponent(value);\n        }\n      }\n\n      value = param.type.decode(value);\n    }\n\n    return param.value(value);\n  };\n  /**\n   * Tests the specified url/path against this matcher.\n   *\n   * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n   * parameter values.  Returns null if the path does not match.\n   *\n   * The returned object contains the values\n   * of any search parameters that are mentioned in the pattern, but their value may be null if\n   * they are not present in `search`. This means that search parameters are always treated\n   * as optional.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n   *   x: '1', q: 'hello'\n   * });\n   * // returns { id: 'bob', q: 'hello', r: null }\n   * ```\n   *\n   * @param path    The URL path to match, e.g. `$location.path()`.\n   * @param search  URL search parameters, e.g. `$location.search()`.\n   * @param hash    URL hash e.g. `$location.hash()`.\n   * @param options\n   *\n   * @returns The captured parameter values.\n   */\n\n\n  UrlMatcher.prototype.exec = function (path, search, hash, options) {\n    var _this = this;\n\n    if (search === void 0) {\n      search = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var match = memoizeTo(this._cache, 'pattern', function () {\n      return new RegExp(['^', unnest(_this._cache.path.map(prop('_compiled'))).join(''), _this.config.strict === false ? '/?' : '', '$'].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n    }).exec(path);\n    if (!match) return null; // options = defaults(options, { isolate: false });\n\n    var allParams = this.parameters(),\n        pathParams = allParams.filter(function (param) {\n      return !param.isSearch();\n    }),\n        searchParams = allParams.filter(function (param) {\n      return param.isSearch();\n    }),\n        nPathSegments = this._cache.path.map(function (urlm) {\n      return urlm._segments.length - 1;\n    }).reduce(function (a, x) {\n      return a + x;\n    }),\n        values = {};\n\n    if (nPathSegments !== match.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\n    function decodePathArray(paramVal) {\n      var reverseString = function (str) {\n        return str.split('').reverse().join('');\n      };\n\n      var unquoteDashes = function (str) {\n        return str.replace(/\\\\-/g, '-');\n      };\n\n      var split = reverseString(paramVal).split(/-(?!\\\\)/);\n      var allReversed = map(split, reverseString);\n      return map(allReversed, unquoteDashes).reverse();\n    }\n\n    for (var i = 0; i < nPathSegments; i++) {\n      var param = pathParams[i];\n      var value = match[i + 1]; // if the param value matches a pre-replace pair, replace the value before decoding.\n\n      for (var j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n\n      if (value && param.array === true) value = decodePathArray(value);\n      values[param.id] = this._getDecodedParamValue(value, param);\n    }\n\n    searchParams.forEach(function (param) {\n      var value = search[param.id];\n\n      for (var j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n\n      values[param.id] = _this._getDecodedParamValue(value, param);\n    });\n    if (hash) values['#'] = hash;\n    return values;\n  };\n  /**\n   * @internal\n   * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n   *\n   * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n   *    pattern has no parameters, an empty array is returned.\n   */\n\n\n  UrlMatcher.prototype.parameters = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.inherit === false) return this._params;\n    return unnest(this._cache.path.map(function (matcher) {\n      return matcher._params;\n    }));\n  };\n  /**\n   * @internal\n   * Returns a single parameter from this UrlMatcher by id\n   *\n   * @param id\n   * @param opts\n   * @returns {T|Param|any|boolean|UrlMatcher|null}\n   */\n\n\n  UrlMatcher.prototype.parameter = function (id, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var findParam = function () {\n      for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n        var param = _a[_i];\n        if (param.id === id) return param;\n      }\n    };\n\n    var parent = this._cache.parent;\n    return findParam() || opts.inherit !== false && parent && parent.parameter(id, opts) || null;\n  };\n  /**\n   * Validates the input parameter values against this UrlMatcher\n   *\n   * Checks an object hash of parameters to validate their correctness according to the parameter\n   * types of this `UrlMatcher`.\n   *\n   * @param params The object hash of parameters to validate.\n   * @returns Returns `true` if `params` validates, otherwise `false`.\n   */\n\n\n  UrlMatcher.prototype.validates = function (params) {\n    var validParamVal = function (param, val) {\n      return !param || param.validates(val);\n    };\n\n    params = params || {}; // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n\n    var paramSchema = this.parameters().filter(function (paramDef) {\n      return params.hasOwnProperty(paramDef.id);\n    });\n    return paramSchema.map(function (paramDef) {\n      return validParamVal(paramDef, params[paramDef.id]);\n    }).reduce(allTrueR, true);\n  };\n  /**\n   * Given a set of parameter values, creates a URL from this UrlMatcher.\n   *\n   * Creates a URL that matches this pattern by substituting the specified values\n   * for the path and search parameters.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n   * // returns '/user/bob?q=yes'\n   * ```\n   *\n   * @param values  the values to substitute for the parameters in this pattern.\n   * @returns the formatted URL (path and optionally search part).\n   */\n\n\n  UrlMatcher.prototype.format = function (values) {\n    if (values === void 0) {\n      values = {};\n    } // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\n\n    var urlMatchers = this._cache.path; // Extract all the static segments and Params (processed as ParamDetails)\n    // into an ordered array\n\n    var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).map(function (x) {\n      return isString(x) ? x : getDetails(x);\n    }); // Extract the query params into a separate array\n\n    var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(unnestR, []).map(getDetails);\n\n    var isInvalid = function (param) {\n      return param.isValid === false;\n    };\n\n    if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n      return null;\n    }\n    /**\n     * Given a Param, applies the parameter value, then returns detailed information about it\n     */\n\n\n    function getDetails(param) {\n      // Normalize to typed value\n      var value = param.value(values[param.id]);\n      var isValid = param.validates(value);\n      var isDefaultValue = param.isDefaultValue(value); // Check if we're in squash mode for the parameter\n\n      var squash = isDefaultValue ? param.squash : false; // Allow the Parameter's Type to encode the value\n\n      var encoded = param.type.encode(value);\n      return {\n        param: param,\n        value: value,\n        isValid: isValid,\n        isDefaultValue: isDefaultValue,\n        squash: squash,\n        encoded: encoded\n      };\n    } // Build up the path-portion from the list of static segments and parameters\n\n\n    var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n      // The element is a static segment (a raw string); just append it\n      if (isString(x)) return acc + x; // Otherwise, it's a ParamDetails.\n\n      var squash = x.squash,\n          encoded = x.encoded,\n          param = x.param; // If squash is === true, try to remove a slash from the path\n\n      if (squash === true) return acc.match(/\\/$/) ? acc.slice(0, -1) : acc; // If squash is a string, use the string for the param value\n\n      if (isString(squash)) return acc + squash;\n      if (squash !== false) return acc; // ?\n\n      if (encoded == null) return acc; // If this parameter value is an array, encode the value using encodeDashes\n\n      if (isArray(encoded)) return acc + map(encoded, UrlMatcher.encodeDashes).join('-'); // If the parameter type is \"raw\", then do not encodeURIComponent\n\n      if (param.raw) return acc + encoded; // Encode the value\n\n      return acc + encodeURIComponent(encoded);\n    }, ''); // Build the query string by applying parameter values (array or regular)\n    // then mapping to key=value, then flattening and joining using \"&\"\n\n    var queryString = queryParams.map(function (paramDetails) {\n      var param = paramDetails.param,\n          squash = paramDetails.squash,\n          encoded = paramDetails.encoded,\n          isDefaultValue = paramDetails.isDefaultValue;\n      if (encoded == null || isDefaultValue && squash !== false) return;\n      if (!isArray(encoded)) encoded = [encoded];\n      if (encoded.length === 0) return;\n      if (!param.raw) encoded = map(encoded, encodeURIComponent);\n      return encoded.map(function (val) {\n        return param.id + \"=\" + val;\n      });\n    }).filter(identity).reduce(unnestR, []).join('&'); // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\n    return pathString + (queryString ? \"?\" + queryString : '') + (values['#'] ? '#' + values['#'] : '');\n  };\n  /** @internal */\n\n\n  UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n  return UrlMatcher;\n}();\n\nexport { UrlMatcher };","map":{"version":3,"mappings":"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","names":["map","inherit","identity","unnest","tail","find","allTrueR","unnestR","arrayTuples","prop","propEq","isArray","isString","isDefined","Param","DefType","joinNeighborsR","splitOnDelim","defaults","quoteRegExp","str","param","surroundPattern","result","replace","squash","isOptional","type","pattern","source","memoizeTo","obj","_prop","fn","splitOnSlash","defaultConfig","state","params","strict","caseInsensitive","decodeParams","paramTypes","paramFactory","config","path","placeholder","searchPlaceholder","patterns","last","matchArray","checkParamErrors","id","UrlMatcher","nameValidator","test","Error","_this","_params","matchDetails","m","isSearch","regexp","makeRegexpType","RegExp","undefined","segment","substring","index","details","exec","indexOf","push","fromPath","_segments","lastIndex","i","search","length","fromSearch","_compiled","_pattern","apply","concat","encodeURIComponent","c","charCodeAt","toString","toUpperCase","matcher","staticSegments","pathParams","filter","p","location","PATH","reduce","x","SEARCH","a","b","segments","_cache","pathSegmentsAndParams","weights","padArrays","l","r","padVal","len","Math","max","weightsA","weightsB","_pairs","cmp","url","_children","parent","value","raw","paramValue","decodeURIComponent","decode","hash","options","match","join","allParams","parameters","searchParams","nPathSegments","urlm","values","decodePathArray","paramVal","reverseString","split","reverse","unquoteDashes","allReversed","j","from","to","array","_getDecodedParamValue","forEach","opts","findParam","_i","parameter","validParamVal","val","validates","paramSchema","paramDef","hasOwnProperty","urlMatchers","getDetails","queryParams","isInvalid","isValid","isDefaultValue","encoded","encode","pathString","acc","slice","encodeDashes","queryString","paramDetails"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\url\\@uirouter\\core\\url\\urlMatcher.ts"],"sourcesContent":["import { map, inherit, identity, unnest, tail, find, Obj, allTrueR, unnestR, arrayTuples } from '../common/common';\nimport { prop, propEq } from '../common/hof';\nimport { isArray, isString, isDefined } from '../common/predicates';\nimport { Param, DefType } from '../params/param';\nimport { ParamTypes } from '../params/paramTypes';\nimport { RawParams } from '../params/interface';\nimport { UrlMatcherCompileConfig } from './interface';\nimport { joinNeighborsR, splitOnDelim } from '../common/strings';\nimport { ParamType } from '../params';\nimport { defaults } from '../common';\nimport { ParamFactory } from './urlMatcherFactory';\n\nfunction quoteRegExp(str: any, param?: any) {\n  let surroundPattern = ['', ''],\n    result = str.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, '\\\\$&');\n  if (!param) return result;\n\n  switch (param.squash) {\n    case false:\n      surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n      break;\n    case true:\n      result = result.replace(/\\/$/, '');\n      surroundPattern = ['(?:/(', ')|/)?'];\n      break;\n    default:\n      surroundPattern = [`(${param.squash}|`, ')?'];\n      break;\n  }\n  return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n\nconst memoizeTo = (obj: Obj, _prop: string, fn: Function) => (obj[_prop] = obj[_prop] || fn());\n\nconst splitOnSlash = splitOnDelim('/');\n\ninterface UrlMatcherCache {\n  segments?: any[];\n  weights?: number[];\n  path?: UrlMatcher[];\n  parent?: UrlMatcher;\n  pattern?: RegExp;\n}\n\ninterface MatchDetails {\n  id: string;\n  regexp: string;\n  segment: string;\n  type: ParamType;\n}\n\nconst defaultConfig: UrlMatcherCompileConfig = {\n  state: { params: {} },\n  strict: true,\n  caseInsensitive: true,\n  decodeParams: true,\n};\n\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nexport class UrlMatcher {\n  /** @internal */\n  static nameValidator: RegExp = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\n  /** @internal */\n  private _cache: UrlMatcherCache = { path: [this] };\n  /** @internal */\n  private _children: UrlMatcher[] = [];\n  /** @internal */\n  private _params: Param[] = [];\n  /** @internal */\n  private _segments: string[] = [];\n  /** @internal */\n  private _compiled: string[] = [];\n  /** @internal */\n  private readonly config: UrlMatcherCompileConfig;\n\n  /** The pattern that was passed into the constructor */\n  public pattern: string;\n\n  /** @internal */\n  static encodeDashes(str: string) {\n    // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, (c) => `%5C%${c.charCodeAt(0).toString(16).toUpperCase()}`);\n  }\n\n  /** @internal Given a matcher, return an array with the matcher's path segments and path params, in order */\n  static pathSegmentsAndParams(matcher: UrlMatcher) {\n    const staticSegments = matcher._segments;\n    const pathParams = matcher._params.filter((p) => p.location === DefType.PATH);\n    return arrayTuples(staticSegments, pathParams.concat(undefined))\n      .reduce(unnestR, [])\n      .filter((x) => x !== '' && isDefined(x));\n  }\n\n  /** @internal Given a matcher, return an array with the matcher's query params */\n  static queryParams(matcher: UrlMatcher): Param[] {\n    return matcher._params.filter((p) => p.location === DefType.SEARCH);\n  }\n\n  /**\n   * Compare two UrlMatchers\n   *\n   * This comparison function converts a UrlMatcher into static and dynamic path segments.\n   * Each static path segment is a static string between a path separator (slash character).\n   * Each dynamic segment is a path parameter.\n   *\n   * The comparison function sorts static segments before dynamic ones.\n   */\n  static compare(a: UrlMatcher, b: UrlMatcher): number {\n    /**\n     * Turn a UrlMatcher and all its parent matchers into an array\n     * of slash literals '/', string literals, and Param objects\n     *\n     * This example matcher matches strings like \"/foo/:param/tail\":\n     * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n     * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n     *\n     * Caches the result as `matcher._cache.segments`\n     */\n    const segments = (matcher: UrlMatcher) =>\n      (matcher._cache.segments =\n        matcher._cache.segments ||\n        matcher._cache.path\n          .map(UrlMatcher.pathSegmentsAndParams)\n          .reduce(unnestR, [])\n          .reduce(joinNeighborsR, [])\n          .map((x) => (isString(x) ? splitOnSlash(x) : x))\n          .reduce(unnestR, []));\n\n    /**\n     * Gets the sort weight for each segment of a UrlMatcher\n     *\n     * Caches the result as `matcher._cache.weights`\n     */\n    const weights = (matcher: UrlMatcher) =>\n      (matcher._cache.weights =\n        matcher._cache.weights ||\n        segments(matcher).map((segment) => {\n          // Sort slashes first, then static strings, the Params\n          if (segment === '/') return 1;\n          if (isString(segment)) return 2;\n          if (segment instanceof Param) return 3;\n        }));\n\n    /**\n     * Pads shorter array in-place (mutates)\n     */\n    const padArrays = (l: any[], r: any[], padVal: any) => {\n      const len = Math.max(l.length, r.length);\n      while (l.length < len) l.push(padVal);\n      while (r.length < len) r.push(padVal);\n    };\n\n    const weightsA = weights(a),\n      weightsB = weights(b);\n    padArrays(weightsA, weightsB, 0);\n\n    const _pairs = arrayTuples(weightsA, weightsB);\n    let cmp, i;\n\n    for (i = 0; i < _pairs.length; i++) {\n      cmp = _pairs[i][0] - _pairs[i][1];\n      if (cmp !== 0) return cmp;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param pattern The pattern to compile into a matcher.\n   * @param paramTypes The [[ParamTypes]] registry\n   * @param paramFactory A [[ParamFactory]] object\n   * @param config  A [[UrlMatcherCompileConfig]] configuration object\n   */\n  constructor(pattern: string, paramTypes: ParamTypes, paramFactory: ParamFactory, config?: UrlMatcherCompileConfig) {\n    this.config = config = defaults(config, defaultConfig);\n    this.pattern = pattern;\n\n    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n    //   '*' name\n    //   ':' name\n    //   '{' name '}'\n    //   '{' name ':' regexp '}'\n    // The regular expression is somewhat complicated due to the need to allow curly braces\n    // inside the regular expression. The placeholder regexp breaks down as follows:\n    //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n    //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n    //    [^{}\\\\]+                       - anything other than curly braces or backslash\n    //    \\\\.                            - a backslash escape\n    //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n    const placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n    const searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n    const patterns: any[][] = [];\n    let last = 0;\n    let matchArray: RegExpExecArray;\n\n    const checkParamErrors = (id: string) => {\n      if (!UrlMatcher.nameValidator.test(id)) throw new Error(`Invalid parameter name '${id}' in pattern '${pattern}'`);\n      if (find(this._params, propEq('id', id)))\n        throw new Error(`Duplicate parameter name '${id}' in pattern '${pattern}'`);\n    };\n\n    // Split into static segments separated by path parameter placeholders.\n    // The number of segments is always 1 more than the number of parameters.\n    const matchDetails = (m: RegExpExecArray, isSearch: boolean): MatchDetails => {\n      // IE[78] returns '' for unmatched groups instead of null\n      const id: string = m[2] || m[3];\n      const regexp: string = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n\n      const makeRegexpType = (str) =>\n        inherit(paramTypes.type(isSearch ? 'query' : 'path'), {\n          pattern: new RegExp(str, this.config.caseInsensitive ? 'i' : undefined),\n        });\n\n      return {\n        id,\n        regexp,\n        segment: pattern.substring(last, m.index),\n        type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),\n      };\n    };\n\n    let details: MatchDetails;\n    let segment: string;\n\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((matchArray = placeholder.exec(pattern))) {\n      details = matchDetails(matchArray, false);\n      if (details.segment.indexOf('?') >= 0) break; // we're into the search part\n\n      checkParamErrors(details.id);\n      this._params.push(paramFactory.fromPath(details.id, details.type, config.state));\n      this._segments.push(details.segment);\n      patterns.push([details.segment, tail(this._params)]);\n      last = placeholder.lastIndex;\n    }\n    segment = pattern.substring(last);\n\n    // Find any search parameter names and remove them from the last segment\n    const i = segment.indexOf('?');\n\n    if (i >= 0) {\n      const search = segment.substring(i);\n      segment = segment.substring(0, i);\n\n      if (search.length > 0) {\n        last = 0;\n\n        // tslint:disable-next-line:no-conditional-assignment\n        while ((matchArray = searchPlaceholder.exec(search))) {\n          details = matchDetails(matchArray, true);\n          checkParamErrors(details.id);\n          this._params.push(paramFactory.fromSearch(details.id, details.type, config.state));\n          last = placeholder.lastIndex;\n          // check if ?&\n        }\n      }\n    }\n\n    this._segments.push(segment);\n    this._compiled = patterns.map((_pattern) => quoteRegExp.apply(null, _pattern)).concat(quoteRegExp(segment));\n  }\n\n  /**\n   * Creates a new concatenated UrlMatcher\n   *\n   * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n   *\n   * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n   */\n  append(url: UrlMatcher): UrlMatcher {\n    this._children.push(url);\n    url._cache = {\n      path: this._cache.path.concat(url),\n      parent: this,\n      pattern: null,\n    };\n    return url;\n  }\n\n  /** @internal */\n  isRoot(): boolean {\n    return this._cache.path[0] === this;\n  }\n\n  /** Returns the input pattern string */\n  toString(): string {\n    return this.pattern;\n  }\n\n  private _getDecodedParamValue(value: any, param: Param): any {\n    if (isDefined(value)) {\n      if (this.config.decodeParams && !param.type.raw) {\n        if (isArray(value)) {\n          value = value.map((paramValue) => decodeURIComponent(paramValue));\n        } else {\n          value = decodeURIComponent(value);\n        }\n      }\n\n      value = param.type.decode(value);\n    }\n\n    return param.value(value);\n  }\n\n  /**\n   * Tests the specified url/path against this matcher.\n   *\n   * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n   * parameter values.  Returns null if the path does not match.\n   *\n   * The returned object contains the values\n   * of any search parameters that are mentioned in the pattern, but their value may be null if\n   * they are not present in `search`. This means that search parameters are always treated\n   * as optional.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n   *   x: '1', q: 'hello'\n   * });\n   * // returns { id: 'bob', q: 'hello', r: null }\n   * ```\n   *\n   * @param path    The URL path to match, e.g. `$location.path()`.\n   * @param search  URL search parameters, e.g. `$location.search()`.\n   * @param hash    URL hash e.g. `$location.hash()`.\n   * @param options\n   *\n   * @returns The captured parameter values.\n   */\n  exec(path: string, search: any = {}, hash?: string, options: any = {}): RawParams {\n    const match = memoizeTo(this._cache, 'pattern', () => {\n      return new RegExp(\n        [\n          '^',\n          unnest(this._cache.path.map(prop('_compiled'))).join(''),\n          this.config.strict === false ? '/?' : '',\n          '$',\n        ].join(''),\n        this.config.caseInsensitive ? 'i' : undefined\n      );\n    }).exec(path);\n\n    if (!match) return null;\n\n    // options = defaults(options, { isolate: false });\n\n    const allParams: Param[] = this.parameters(),\n      pathParams: Param[] = allParams.filter((param) => !param.isSearch()),\n      searchParams: Param[] = allParams.filter((param) => param.isSearch()),\n      nPathSegments = this._cache.path.map((urlm) => urlm._segments.length - 1).reduce((a, x) => a + x),\n      values: RawParams = {};\n\n    if (nPathSegments !== match.length - 1) throw new Error(`Unbalanced capture group in route '${this.pattern}'`);\n\n    function decodePathArray(paramVal: string) {\n      const reverseString = (str: string) => str.split('').reverse().join('');\n      const unquoteDashes = (str: string) => str.replace(/\\\\-/g, '-');\n\n      const split = reverseString(paramVal).split(/-(?!\\\\)/);\n      const allReversed = map(split, reverseString);\n      return map(allReversed, unquoteDashes).reverse();\n    }\n\n    for (let i = 0; i < nPathSegments; i++) {\n      const param: Param = pathParams[i];\n      let value: any | any[] = match[i + 1];\n\n      // if the param value matches a pre-replace pair, replace the value before decoding.\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n\n      if (value && param.array === true) value = decodePathArray(value);\n\n      values[param.id] = this._getDecodedParamValue(value, param);\n    }\n    searchParams.forEach((param: Param) => {\n      let value = search[param.id];\n\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n\n      values[param.id] = this._getDecodedParamValue(value, param);\n    });\n\n    if (hash) values['#'] = hash;\n\n    return values;\n  }\n\n  /**\n   * @internal\n   * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n   *\n   * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n   *    pattern has no parameters, an empty array is returned.\n   */\n  parameters(opts: any = {}): Param[] {\n    if (opts.inherit === false) return this._params;\n    return unnest(this._cache.path.map((matcher) => matcher._params));\n  }\n\n  /**\n   * @internal\n   * Returns a single parameter from this UrlMatcher by id\n   *\n   * @param id\n   * @param opts\n   * @returns {T|Param|any|boolean|UrlMatcher|null}\n   */\n  parameter(id: string, opts: any = {}): Param {\n    const findParam = () => {\n      for (const param of this._params) {\n        if (param.id === id) return param;\n      }\n    };\n\n    const parent = this._cache.parent;\n    return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n  }\n\n  /**\n   * Validates the input parameter values against this UrlMatcher\n   *\n   * Checks an object hash of parameters to validate their correctness according to the parameter\n   * types of this `UrlMatcher`.\n   *\n   * @param params The object hash of parameters to validate.\n   * @returns Returns `true` if `params` validates, otherwise `false`.\n   */\n  validates(params: RawParams): boolean {\n    const validParamVal = (param: Param, val: any) => !param || param.validates(val);\n\n    params = params || {};\n\n    // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n    const paramSchema = this.parameters().filter((paramDef) => params.hasOwnProperty(paramDef.id));\n    return paramSchema.map((paramDef) => validParamVal(paramDef, params[paramDef.id])).reduce(allTrueR, true);\n  }\n\n  /**\n   * Given a set of parameter values, creates a URL from this UrlMatcher.\n   *\n   * Creates a URL that matches this pattern by substituting the specified values\n   * for the path and search parameters.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n   * // returns '/user/bob?q=yes'\n   * ```\n   *\n   * @param values  the values to substitute for the parameters in this pattern.\n   * @returns the formatted URL (path and optionally search part).\n   */\n  format(values: RawParams = {}) {\n    // Build the full path of UrlMatchers (including all parent UrlMatchers)\n    const urlMatchers = this._cache.path;\n\n    // Extract all the static segments and Params (processed as ParamDetails)\n    // into an ordered array\n    const pathSegmentsAndParams: Array<string | ParamDetails> = urlMatchers\n      .map(UrlMatcher.pathSegmentsAndParams)\n      .reduce(unnestR, [])\n      .map((x) => (isString(x) ? x : getDetails(x)));\n\n    // Extract the query params into a separate array\n    const queryParams: Array<ParamDetails> = urlMatchers\n      .map(UrlMatcher.queryParams)\n      .reduce(unnestR, [])\n      .map(getDetails);\n\n    const isInvalid = (param: ParamDetails) => param.isValid === false;\n    if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n      return null;\n    }\n\n    /**\n     * Given a Param, applies the parameter value, then returns detailed information about it\n     */\n    function getDetails(param: Param): ParamDetails {\n      // Normalize to typed value\n      const value = param.value(values[param.id]);\n      const isValid = param.validates(value);\n      const isDefaultValue = param.isDefaultValue(value);\n      // Check if we're in squash mode for the parameter\n      const squash = isDefaultValue ? param.squash : false;\n      // Allow the Parameter's Type to encode the value\n      const encoded = param.type.encode(value);\n\n      return { param, value, isValid, isDefaultValue, squash, encoded };\n    }\n\n    // Build up the path-portion from the list of static segments and parameters\n    const pathString = pathSegmentsAndParams.reduce((acc: string, x: string | ParamDetails) => {\n      // The element is a static segment (a raw string); just append it\n      if (isString(x)) return acc + x;\n\n      // Otherwise, it's a ParamDetails.\n      const { squash, encoded, param } = x;\n\n      // If squash is === true, try to remove a slash from the path\n      if (squash === true) return acc.match(/\\/$/) ? acc.slice(0, -1) : acc;\n      // If squash is a string, use the string for the param value\n      if (isString(squash)) return acc + squash;\n      if (squash !== false) return acc; // ?\n      if (encoded == null) return acc;\n      // If this parameter value is an array, encode the value using encodeDashes\n      if (isArray(encoded)) return acc + map(<string[]>encoded, UrlMatcher.encodeDashes).join('-');\n      // If the parameter type is \"raw\", then do not encodeURIComponent\n      if (param.raw) return acc + encoded;\n      // Encode the value\n      return acc + encodeURIComponent(<string>encoded);\n    }, '');\n\n    // Build the query string by applying parameter values (array or regular)\n    // then mapping to key=value, then flattening and joining using \"&\"\n    const queryString = queryParams\n      .map((paramDetails: ParamDetails) => {\n        let { param, squash, encoded, isDefaultValue } = paramDetails;\n        if (encoded == null || (isDefaultValue && squash !== false)) return;\n        if (!isArray(encoded)) encoded = [<string>encoded];\n        if (encoded.length === 0) return;\n        if (!param.raw) encoded = map(<string[]>encoded, encodeURIComponent);\n\n        return (<string[]>encoded).map((val) => `${param.id}=${val}`);\n      })\n      .filter(identity)\n      .reduce(unnestR, [])\n      .join('&');\n\n    // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n    return pathString + (queryString ? `?${queryString}` : '') + (values['#'] ? '#' + values['#'] : '');\n  }\n}\n\n/** @internal */\ninterface ParamDetails {\n  param: Param;\n  value: any;\n  isValid: boolean;\n  isDefaultValue: boolean;\n  squash: boolean | string;\n  encoded: string | string[];\n}\n"]},"metadata":{},"sourceType":"module"}