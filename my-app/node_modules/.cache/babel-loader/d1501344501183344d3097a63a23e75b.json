{"ast":null,"code":"import { StateMatcher } from './stateMatcher';\nimport { StateBuilder } from './stateBuilder';\nimport { StateQueueManager } from './stateQueueManager';\nimport { removeFrom } from '../common/common';\nimport { propEq } from '../common/hof';\n/**\n * A registry for all of the application's [[StateDeclaration]]s\n *\n * This API is found at `router.stateRegistry` ([[UIRouter.stateRegistry]])\n */\n\nvar StateRegistry =\n/** @class */\nfunction () {\n  /** @internal */\n  function StateRegistry(router) {\n    this.router = router;\n    this.states = {};\n    /** @internal */\n\n    this.listeners = [];\n    this.matcher = new StateMatcher(this.states);\n    this.builder = new StateBuilder(this.matcher, router.urlMatcherFactory);\n    this.stateQueue = new StateQueueManager(router, this.states, this.builder, this.listeners);\n\n    this._registerRoot();\n  }\n  /** @internal */\n\n\n  StateRegistry.prototype._registerRoot = function () {\n    var rootStateDef = {\n      name: '',\n      url: '^',\n      views: null,\n      params: {\n        '#': {\n          value: null,\n          type: 'hash',\n          dynamic: true\n        }\n      },\n      abstract: true\n    };\n\n    var _root = this._root = this.stateQueue.register(rootStateDef);\n\n    _root.navigable = null;\n  };\n  /** @internal */\n\n\n  StateRegistry.prototype.dispose = function () {\n    var _this = this;\n\n    this.stateQueue.dispose();\n    this.listeners = [];\n    this.get().forEach(function (state) {\n      return _this.get(state) && _this.deregister(state);\n    });\n  };\n  /**\n   * Listen for a State Registry events\n   *\n   * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n   *\n   * #### Example:\n   * ```js\n   * let allStates = registry.get();\n   *\n   * // Later, invoke deregisterFn() to remove the listener\n   * let deregisterFn = registry.onStatesChanged((event, states) => {\n   *   switch(event) {\n   *     case: 'registered':\n   *       states.forEach(state => allStates.push(state));\n   *       break;\n   *     case: 'deregistered':\n   *       states.forEach(state => {\n   *         let idx = allStates.indexOf(state);\n   *         if (idx !== -1) allStates.splice(idx, 1);\n   *       });\n   *       break;\n   *   }\n   * });\n   * ```\n   *\n   * @param listener a callback function invoked when the registered states changes.\n   *        The function receives two parameters, `event` and `state`.\n   *        See [[StateRegistryListener]]\n   * @return a function that deregisters the listener\n   */\n\n\n  StateRegistry.prototype.onStatesChanged = function (listener) {\n    this.listeners.push(listener);\n    return function deregisterListener() {\n      removeFrom(this.listeners)(listener);\n    }.bind(this);\n  };\n  /**\n   * Gets the implicit root state\n   *\n   * Gets the root of the state tree.\n   * The root state is implicitly created by UI-Router.\n   * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n   *\n   * @return the root [[StateObject]]\n   */\n\n\n  StateRegistry.prototype.root = function () {\n    return this._root;\n  };\n  /**\n   * Adds a state to the registry\n   *\n   * Registers a [[StateDeclaration]] or queues it for registration.\n   *\n   * Note: a state will be queued if the state's parent isn't yet registered.\n   *\n   * @param stateDefinition the definition of the state to register.\n   * @returns the internal [[StateObject]] object.\n   *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n   *          If the state was only queued, then the object is not fully built.\n   */\n\n\n  StateRegistry.prototype.register = function (stateDefinition) {\n    return this.stateQueue.register(stateDefinition);\n  };\n  /** @internal */\n\n\n  StateRegistry.prototype._deregisterTree = function (state) {\n    var _this = this;\n\n    var all = this.get().map(function (s) {\n      return s.$$state();\n    });\n\n    var getChildren = function (states) {\n      var _children = all.filter(function (s) {\n        return states.indexOf(s.parent) !== -1;\n      });\n\n      return _children.length === 0 ? _children : _children.concat(getChildren(_children));\n    };\n\n    var children = getChildren([state]);\n    var deregistered = [state].concat(children).reverse();\n    deregistered.forEach(function (_state) {\n      var rulesApi = _this.router.urlService.rules; // Remove URL rule\n\n      rulesApi.rules().filter(propEq('state', _state)).forEach(function (rule) {\n        return rulesApi.removeRule(rule);\n      }); // Remove state from registry\n\n      delete _this.states[_state.name];\n    });\n    return deregistered;\n  };\n  /**\n   * Removes a state from the registry\n   *\n   * This removes a state from the registry.\n   * If the state has children, they are are also removed from the registry.\n   *\n   * @param stateOrName the state's name or object representation\n   * @returns {StateObject[]} a list of removed states\n   */\n\n\n  StateRegistry.prototype.deregister = function (stateOrName) {\n    var _state = this.get(stateOrName);\n\n    if (!_state) throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\n    var deregisteredStates = this._deregisterTree(_state.$$state());\n\n    this.listeners.forEach(function (listener) {\n      return listener('deregistered', deregisteredStates.map(function (s) {\n        return s.self;\n      }));\n    });\n    return deregisteredStates;\n  };\n\n  StateRegistry.prototype.get = function (stateOrName, base) {\n    var _this = this;\n\n    if (arguments.length === 0) return Object.keys(this.states).map(function (name) {\n      return _this.states[name].self;\n    });\n    var found = this.matcher.find(stateOrName, base);\n    return found && found.self || null;\n  };\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param property The name of the State property being registered for.\n   * @param builderFunction The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n\n\n  StateRegistry.prototype.decorator = function (property, builderFunction) {\n    return this.builder.builder(property, builderFunction);\n  };\n\n  return StateRegistry;\n}();\n\nexport { StateRegistry };","map":{"version":3,"mappings":"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","names":["StateMatcher","StateBuilder","StateQueueManager","removeFrom","propEq","router","matcher","states","builder","urlMatcherFactory","stateQueue","listeners","_registerRoot","StateRegistry","rootStateDef","name","url","views","params","value","type","dynamic","abstract","_root","register","navigable","dispose","get","forEach","state","_this","deregister","listener","push","deregisterListener","bind","stateDefinition","all","map","s","$$state","getChildren","_children","filter","indexOf","parent","length","concat","children","deregistered","reverse","_state","rulesApi","urlService","rules","rule","removeRule","stateOrName","Error","deregisteredStates","_deregisterTree","self","base","arguments","Object","keys","found","find","property","builderFunction"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\state\\@uirouter\\core\\state\\stateRegistry.ts"],"sourcesContent":["import { StateObject } from './stateObject';\nimport { StateMatcher } from './stateMatcher';\nimport { StateBuilder } from './stateBuilder';\nimport { StateQueueManager } from './stateQueueManager';\nimport { StateDeclaration, _StateDeclaration } from './interface';\nimport { BuilderFunction } from './stateBuilder';\nimport { StateOrName } from './interface';\nimport { removeFrom } from '../common/common';\nimport { UIRouter } from '../router';\nimport { propEq } from '../common/hof';\n\n/**\n * The signature for the callback function provided to [[StateRegistry.onStatesChanged]].\n *\n * This callback receives two parameters:\n *\n * @param event a string; either \"registered\" or \"deregistered\"\n * @param states the list of [[StateDeclaration]]s that were registered (or deregistered).\n */\nexport type StateRegistryListener = (event: 'registered' | 'deregistered', states: StateDeclaration[]) => void;\n\n/**\n * A registry for all of the application's [[StateDeclaration]]s\n *\n * This API is found at `router.stateRegistry` ([[UIRouter.stateRegistry]])\n */\nexport class StateRegistry {\n  private _root: StateObject;\n  private states: { [key: string]: StateObject } = {};\n\n  /** @internal */\n  matcher: StateMatcher;\n  private builder: StateBuilder;\n  /** @internal */\n  stateQueue: StateQueueManager;\n\n  /** @internal */\n  listeners: StateRegistryListener[] = [];\n\n  /** @internal */\n  constructor(private router: UIRouter) {\n    this.matcher = new StateMatcher(this.states);\n    this.builder = new StateBuilder(this.matcher, router.urlMatcherFactory);\n    this.stateQueue = new StateQueueManager(router, this.states, this.builder, this.listeners);\n    this._registerRoot();\n  }\n\n  /** @internal */\n  private _registerRoot() {\n    const rootStateDef: StateDeclaration = {\n      name: '',\n      url: '^',\n      views: null,\n      params: {\n        '#': { value: null, type: 'hash', dynamic: true },\n      },\n      abstract: true,\n    };\n\n    const _root = (this._root = this.stateQueue.register(rootStateDef));\n    _root.navigable = null;\n  }\n\n  /** @internal */\n  dispose() {\n    this.stateQueue.dispose();\n    this.listeners = [];\n    this.get().forEach((state) => this.get(state) && this.deregister(state));\n  }\n\n  /**\n   * Listen for a State Registry events\n   *\n   * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n   *\n   * #### Example:\n   * ```js\n   * let allStates = registry.get();\n   *\n   * // Later, invoke deregisterFn() to remove the listener\n   * let deregisterFn = registry.onStatesChanged((event, states) => {\n   *   switch(event) {\n   *     case: 'registered':\n   *       states.forEach(state => allStates.push(state));\n   *       break;\n   *     case: 'deregistered':\n   *       states.forEach(state => {\n   *         let idx = allStates.indexOf(state);\n   *         if (idx !== -1) allStates.splice(idx, 1);\n   *       });\n   *       break;\n   *   }\n   * });\n   * ```\n   *\n   * @param listener a callback function invoked when the registered states changes.\n   *        The function receives two parameters, `event` and `state`.\n   *        See [[StateRegistryListener]]\n   * @return a function that deregisters the listener\n   */\n  onStatesChanged(listener: StateRegistryListener): () => void {\n    this.listeners.push(listener);\n    return function deregisterListener() {\n      removeFrom(this.listeners)(listener);\n    }.bind(this);\n  }\n\n  /**\n   * Gets the implicit root state\n   *\n   * Gets the root of the state tree.\n   * The root state is implicitly created by UI-Router.\n   * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n   *\n   * @return the root [[StateObject]]\n   */\n  root() {\n    return this._root;\n  }\n\n  /**\n   * Adds a state to the registry\n   *\n   * Registers a [[StateDeclaration]] or queues it for registration.\n   *\n   * Note: a state will be queued if the state's parent isn't yet registered.\n   *\n   * @param stateDefinition the definition of the state to register.\n   * @returns the internal [[StateObject]] object.\n   *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n   *          If the state was only queued, then the object is not fully built.\n   */\n  register(stateDefinition: _StateDeclaration): StateObject {\n    return this.stateQueue.register(stateDefinition);\n  }\n\n  /** @internal */\n  private _deregisterTree(state: StateObject) {\n    const all = this.get().map((s) => s.$$state());\n    const getChildren = (states: StateObject[]) => {\n      const _children = all.filter((s) => states.indexOf(s.parent) !== -1);\n      return _children.length === 0 ? _children : _children.concat(getChildren(_children));\n    };\n\n    const children = getChildren([state]);\n    const deregistered: StateObject[] = [state].concat(children).reverse();\n\n    deregistered.forEach((_state) => {\n      const rulesApi = this.router.urlService.rules;\n\n      // Remove URL rule\n      rulesApi\n        .rules()\n        .filter(propEq('state', _state))\n        .forEach((rule) => rulesApi.removeRule(rule));\n\n      // Remove state from registry\n      delete this.states[_state.name];\n    });\n\n    return deregistered;\n  }\n\n  /**\n   * Removes a state from the registry\n   *\n   * This removes a state from the registry.\n   * If the state has children, they are are also removed from the registry.\n   *\n   * @param stateOrName the state's name or object representation\n   * @returns {StateObject[]} a list of removed states\n   */\n  deregister(stateOrName: StateOrName) {\n    const _state = this.get(stateOrName);\n    if (!_state) throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n    const deregisteredStates = this._deregisterTree(_state.$$state());\n\n    this.listeners.forEach((listener) =>\n      listener(\n        'deregistered',\n        deregisteredStates.map((s) => s.self)\n      )\n    );\n    return deregisteredStates;\n  }\n\n  /**\n   * Gets all registered states\n   *\n   * Calling this method with no arguments will return a list of all the states that are currently registered.\n   * Note: this does not return states that are *queued* but not yet registered.\n   *\n   * @return a list of [[StateDeclaration]]s\n   */\n  get(): StateDeclaration[];\n\n  /**\n   * Gets a registered state\n   *\n   * Given a state or a name, finds and returns the [[StateDeclaration]] from the registry.\n   * Note: this does not return states that are *queued* but not yet registered.\n   *\n   * @param stateOrName either the name of a state, or a state object.\n   * @param base the base state to use when stateOrName is relative.\n   * @return a registered [[StateDeclaration]] that matched the `stateOrName`, or null if the state isn't registered.\n   */\n  get(stateOrName: StateOrName, base?: StateOrName): StateDeclaration;\n  get(stateOrName?: StateOrName, base?: StateOrName): any {\n    if (arguments.length === 0)\n      return <StateDeclaration[]>Object.keys(this.states).map((name) => this.states[name].self);\n    const found = this.matcher.find(stateOrName, base);\n    return (found && found.self) || null;\n  }\n\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param property The name of the State property being registered for.\n   * @param builderFunction The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n  decorator(property: string, builderFunction: BuilderFunction) {\n    return this.builder.builder(property, builderFunction);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}