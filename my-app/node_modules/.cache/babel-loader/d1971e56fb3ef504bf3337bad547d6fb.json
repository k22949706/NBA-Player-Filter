{"ast":null,"code":"import { Transition } from '../transition/transition';\nimport { UIRouter } from '../router';\nimport { Resolvable } from '../resolve';\nimport { inArray, uniqR, unnestR, values } from '../common';\n\nfunction addCoreResolvables(trans) {\n  trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');\n  trans.addResolvable(Resolvable.fromData(Transition, trans), '');\n  trans.addResolvable(Resolvable.fromData('$transition$', trans), '');\n  trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');\n  trans.entering().forEach(function (state) {\n    trans.addResolvable(Resolvable.fromData('$state$', state), state);\n  });\n}\n\nexport var registerAddCoreResolvables = function (transitionService) {\n  return transitionService.onCreate({}, addCoreResolvables);\n};\nvar TRANSITION_TOKENS = ['$transition$', Transition];\nvar isTransition = inArray(TRANSITION_TOKENS); // References to Transition in the treeChanges pathnodes makes all\n// previous Transitions reachable in memory, causing a memory leak\n// This function removes resolves for '$transition$' and `Transition` from the treeChanges.\n// Do not use this on current transitions, only on old ones.\n\nexport var treeChangesCleanup = function (trans) {\n  var nodes = values(trans.treeChanges()).reduce(unnestR, []).reduce(uniqR, []); // If the resolvable is a Transition, return a new resolvable with null data\n\n  var replaceTransitionWithNull = function (r) {\n    return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;\n  };\n\n  nodes.forEach(function (node) {\n    node.resolvables = node.resolvables.map(replaceTransitionWithNull);\n  });\n};","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,QAA2B,0BAA3B;AACA,SAASC,QAAT,QAAyB,WAAzB;AAEA,SAASC,UAAT,QAA2B,YAA3B;AACA,SAASC,OAAT,EAAkBC,KAAlB,EAAyBC,OAAzB,EAAkCC,MAAlC,QAAgD,WAAhD;;AAGA,SAASC,kBAAT,CAA4BC,KAA5B,EAA6C;EAC3CA,KAAK,CAACC,aAAN,CAAoBP,UAAU,CAACQ,QAAX,CAAoBT,QAApB,EAA8BO,KAAK,CAACG,MAApC,CAApB,EAAiE,EAAjE;EACAH,KAAK,CAACC,aAAN,CAAoBP,UAAU,CAACQ,QAAX,CAAoBV,UAApB,EAAgCQ,KAAhC,CAApB,EAA4D,EAA5D;EACAA,KAAK,CAACC,aAAN,CAAoBP,UAAU,CAACQ,QAAX,CAAoB,cAApB,EAAoCF,KAApC,CAApB,EAAgE,EAAhE;EACAA,KAAK,CAACC,aAAN,CAAoBP,UAAU,CAACQ,QAAX,CAAoB,cAApB,EAAoCF,KAAK,CAACI,MAAN,EAApC,CAApB,EAAyE,EAAzE;EAEAJ,KAAK,CAACK,QAAN,GAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAM;IAC7BP,KAAK,CAACC,aAAN,CAAoBP,UAAU,CAACQ,QAAX,CAAoB,SAApB,EAA+BK,KAA/B,CAApB,EAA2DA,KAA3D;EACD,CAFD;AAGD;;AAED,OAAO,IAAMC,0BAA0B,GAAG,UAACC,iBAAD,EAAqC;EAC7E,wBAAiB,CAACC,QAAlB,CAA2B,EAA3B,EAA+BX,kBAA/B;AAAkD,CAD7C;AAGP,IAAMY,iBAAiB,GAAG,CAAC,cAAD,EAAiBnB,UAAjB,CAA1B;AACA,IAAMoB,YAAY,GAAGjB,OAAO,CAACgB,iBAAD,CAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,IAAME,kBAAkB,GAAG,UAACb,KAAD,EAAkB;EAClD,IAAMc,KAAK,GAAGhB,MAAM,CAACE,KAAK,CAACe,WAAN,EAAD,CAAN,CAA4BC,MAA5B,CAAmCnB,OAAnC,EAA4C,EAA5C,EAAgDmB,MAAhD,CAAuDpB,KAAvD,EAA8D,EAA9D,CAAd,CADkD,CAGlD;;EACA,IAAMqB,yBAAyB,GAAG,UAACC,CAAD,EAAc;IAC9C,OAAON,YAAY,CAACM,CAAC,CAACC,KAAH,CAAZ,GAAwBzB,UAAU,CAACQ,QAAX,CAAoBgB,CAAC,CAACC,KAAtB,EAA6B,IAA7B,CAAxB,GAA6DD,CAApE;EACD,CAFD;;EAIAJ,KAAK,CAACR,OAAN,CAAc,UAACc,IAAD,EAAe;IAC3BA,IAAI,CAACC,WAAL,GAAmBD,IAAI,CAACC,WAAL,CAAiBC,GAAjB,CAAqBL,yBAArB,CAAnB;EACD,CAFD;AAGD,CAXM","names":["Transition","UIRouter","Resolvable","inArray","uniqR","unnestR","values","addCoreResolvables","trans","addResolvable","fromData","router","params","entering","forEach","state","registerAddCoreResolvables","transitionService","onCreate","TRANSITION_TOKENS","isTransition","treeChangesCleanup","nodes","treeChanges","reduce","replaceTransitionWithNull","r","token","node","resolvables","map"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\hooks\\@uirouter\\core\\hooks\\coreResolvables.ts"],"sourcesContent":["import { Transition } from '../transition/transition';\nimport { UIRouter } from '../router';\nimport { TransitionService } from '../transition/transitionService';\nimport { Resolvable } from '../resolve';\nimport { inArray, uniqR, unnestR, values } from '../common';\nimport { PathNode } from '../path';\n\nfunction addCoreResolvables(trans: Transition) {\n  trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');\n  trans.addResolvable(Resolvable.fromData(Transition, trans), '');\n  trans.addResolvable(Resolvable.fromData('$transition$', trans), '');\n  trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');\n\n  trans.entering().forEach((state) => {\n    trans.addResolvable(Resolvable.fromData('$state$', state), state);\n  });\n}\n\nexport const registerAddCoreResolvables = (transitionService: TransitionService) =>\n  transitionService.onCreate({}, addCoreResolvables);\n\nconst TRANSITION_TOKENS = ['$transition$', Transition];\nconst isTransition = inArray(TRANSITION_TOKENS);\n\n// References to Transition in the treeChanges pathnodes makes all\n// previous Transitions reachable in memory, causing a memory leak\n// This function removes resolves for '$transition$' and `Transition` from the treeChanges.\n// Do not use this on current transitions, only on old ones.\nexport const treeChangesCleanup = (trans: Transition) => {\n  const nodes = values(trans.treeChanges()).reduce(unnestR, []).reduce(uniqR, []);\n\n  // If the resolvable is a Transition, return a new resolvable with null data\n  const replaceTransitionWithNull = (r: Resolvable): Resolvable => {\n    return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;\n  };\n\n  nodes.forEach((node: PathNode) => {\n    node.resolvables = node.resolvables.map(replaceTransitionWithNull);\n  });\n};\n"]},"metadata":{},"sourceType":"module"}