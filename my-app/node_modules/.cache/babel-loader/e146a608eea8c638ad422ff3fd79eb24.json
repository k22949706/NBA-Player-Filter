{"ast":null,"code":"import { UrlMatcher } from './urlMatcher';\nimport { isString, isDefined, isFunction } from '../common/predicates';\nimport { identity, extend } from '../common/common';\nimport { is, or, pattern } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n */\n\nvar UrlRuleFactory =\n/** @class */\nfunction () {\n  function UrlRuleFactory(router) {\n    this.router = router;\n  }\n\n  UrlRuleFactory.prototype.compile = function (str) {\n    return this.router.urlMatcherFactory.compile(str);\n  };\n\n  UrlRuleFactory.prototype.create = function (what, handler) {\n    var _this = this;\n\n    var isState = StateObject.isState,\n        isStateDeclaration = StateObject.isStateDeclaration;\n    var makeRule = pattern([[isString, function (_what) {\n      return makeRule(_this.compile(_what));\n    }], [is(UrlMatcher), function (_what) {\n      return _this.fromUrlMatcher(_what, handler);\n    }], [or(isState, isStateDeclaration), function (_what) {\n      return _this.fromState(_what, _this.router);\n    }], [is(RegExp), function (_what) {\n      return _this.fromRegExp(_what, handler);\n    }], [isFunction, function (_what) {\n      return new BaseUrlRule(_what, handler);\n    }]]);\n    var rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  };\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n    var _handler = handler;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = function (match) {\n      return handler.format(match);\n    };\n\n    function matchUrlParamters(url) {\n      var params = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(params) && params;\n    } // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n\n\n    function matchPriority(params) {\n      var optional = urlMatcher.parameters().filter(function (param) {\n        return param.isOptional;\n      });\n      if (!optional.length) return 0.000001;\n      var matched = optional.filter(function (param) {\n        return params[param.id];\n      });\n      return matched.length / optional.length;\n    }\n\n    var details = {\n      urlMatcher: urlMatcher,\n      matchPriority: matchPriority,\n      type: 'URLMATCHER'\n    };\n    return extend(new BaseUrlRule(matchUrlParamters, _handler), details);\n  };\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromState = function (stateOrDecl, router) {\n    var state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n\n    var handler = function (match) {\n      var $state = router.stateService;\n      var globals = router.globals;\n\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, {\n          inherit: true,\n          source: 'url'\n        });\n      }\n    };\n\n    var details = {\n      state: state,\n      type: 'STATE'\n    };\n    return extend(this.fromUrlMatcher(state.url, handler), details);\n  };\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n    if (regexp.global || regexp.sticky) throw new Error('Rule RegExp must not be global or sticky');\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n\n    var redirectUrlTo = function (match) {\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n        return match[what === '$' ? 0 : Number(what)];\n      });\n    };\n\n    var _handler = isString(handler) ? redirectUrlTo : handler;\n\n    var matchParamsFromRegexp = function (url) {\n      return regexp.exec(url.path);\n    };\n\n    var details = {\n      regexp: regexp,\n      type: 'REGEXP'\n    };\n    return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);\n  };\n\n  UrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) {\n      return isDefined(obj[key]);\n    });\n  };\n\n  return UrlRuleFactory;\n}();\n\nexport { UrlRuleFactory };\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internal\n */\n\nvar BaseUrlRule =\n/** @class */\nfunction () {\n  function BaseUrlRule(match, handler) {\n    var _this = this;\n\n    this.match = match;\n    this.type = 'RAW';\n\n    this.matchPriority = function (match) {\n      return 0 - _this.$id;\n    };\n\n    this.handler = handler || identity;\n  }\n\n  return BaseUrlRule;\n}();\n\nexport { BaseUrlRule };","map":{"version":3,"mappings":"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","names":["UrlMatcher","isString","isDefined","isFunction","identity","extend","is","or","pattern","StateObject","router","UrlRuleFactory","str","urlMatcherFactory","compile","what","handler","isStateDeclaration","makeRule","_what","_this","fromUrlMatcher","isState","fromState","RegExp","fromRegExp","BaseUrlRule","rule","Error","urlMatcher","_handler","match","format","matchUrlParamters","url","params","exec","path","search","hash","validates","matchPriority","optional","parameters","filter","param","isOptional","length","matched","id","details","type","stateOrDecl","state","$$state","$state","stateService","globals","href","current","transitionTo","inherit","source","regexp","global","sticky","redirectUrlTo","replace","m","Number","matchParamsFromRegexp","obj","every","key","$id"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\url\\@uirouter\\core\\url\\urlRule.ts"],"sourcesContent":["import { StateDeclaration } from '../state';\nimport { UrlMatcher } from './urlMatcher';\nimport { isString, isDefined, isFunction } from '../common/predicates';\nimport { UIRouter } from '../router';\nimport { identity, extend } from '../common/common';\nimport { is, or, pattern } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\nimport { RawParams } from '../params/interface';\nimport {\n  UrlRule,\n  UrlRuleMatchFn,\n  UrlRuleHandlerFn,\n  UrlRuleType,\n  UrlParts,\n  MatcherUrlRule,\n  StateRule,\n  RegExpRule,\n} from './interface';\n\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n */\nexport class UrlRuleFactory {\n  static isUrlRule = (obj) => obj && ['type', 'match', 'handler'].every((key) => isDefined(obj[key]));\n\n  constructor(public router: UIRouter) {}\n\n  compile(str: string) {\n    return this.router.urlMatcherFactory.compile(str);\n  }\n\n  create(\n    what: string | UrlMatcher | StateObject | StateDeclaration | RegExp | UrlRuleMatchFn,\n    handler?: string | UrlRuleHandlerFn\n  ): UrlRule {\n    const { isState, isStateDeclaration } = StateObject;\n    const makeRule = pattern([\n      [isString, (_what: string) => makeRule(this.compile(_what))],\n      [is(UrlMatcher), (_what: UrlMatcher) => this.fromUrlMatcher(_what, handler)],\n      [or(isState, isStateDeclaration), (_what: StateObject | StateDeclaration) => this.fromState(_what, this.router)],\n      [is(RegExp), (_what: RegExp) => this.fromRegExp(_what, handler)],\n      [isFunction, (_what: UrlRuleMatchFn) => new BaseUrlRule(_what, handler as UrlRuleHandlerFn)],\n    ]);\n\n    const rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  }\n\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n  fromUrlMatcher(urlMatcher: UrlMatcher, handler: string | UrlMatcher | UrlRuleHandlerFn): MatcherUrlRule {\n    let _handler: UrlRuleHandlerFn = handler as any;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = (match: RawParams) => (handler as UrlMatcher).format(match);\n\n    function matchUrlParamters(url: UrlParts): RawParams {\n      const params = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(params) && params;\n    }\n\n    // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n    function matchPriority(params: RawParams): number {\n      const optional = urlMatcher.parameters().filter((param) => param.isOptional);\n      if (!optional.length) return 0.000001;\n      const matched = optional.filter((param) => params[param.id]);\n      return matched.length / optional.length;\n    }\n\n    const details = { urlMatcher, matchPriority, type: 'URLMATCHER' };\n    return extend(new BaseUrlRule(matchUrlParamters, _handler), details) as MatcherUrlRule;\n  }\n\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n  fromState(stateOrDecl: StateObject | StateDeclaration, router: UIRouter): StateRule {\n    const state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;\n\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n    const handler = (match: RawParams) => {\n      const $state = router.stateService;\n      const globals = router.globals;\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, { inherit: true, source: 'url' });\n      }\n    };\n\n    const details = { state, type: 'STATE' };\n    return extend(this.fromUrlMatcher(state.url, handler), details) as StateRule;\n  }\n\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n  fromRegExp(regexp: RegExp, handler: string | UrlRuleHandlerFn): RegExpRule {\n    if (regexp.global || regexp.sticky) throw new Error('Rule RegExp must not be global or sticky');\n\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n    const redirectUrlTo = (match: RegExpExecArray) =>\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      (handler as string).replace(/\\$(\\$|\\d{1,2})/, (m, what) => match[what === '$' ? 0 : Number(what)]);\n\n    const _handler = isString(handler) ? redirectUrlTo : handler;\n\n    const matchParamsFromRegexp = (url: UrlParts): RegExpExecArray => regexp.exec(url.path);\n\n    const details = { regexp, type: 'REGEXP' };\n    return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details) as RegExpRule;\n  }\n}\n\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internal\n */\nexport class BaseUrlRule implements UrlRule {\n  $id: number;\n  priority: number;\n  _group: number;\n  type: UrlRuleType = 'RAW';\n  handler: UrlRuleHandlerFn;\n  matchPriority = (match) => 0 - this.$id;\n\n  constructor(public match: UrlRuleMatchFn, handler?: UrlRuleHandlerFn) {\n    this.handler = handler || identity;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}