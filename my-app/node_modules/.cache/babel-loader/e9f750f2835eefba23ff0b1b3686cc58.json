{"ast":null,"code":"import { extend, applyPairs, find } from '../common/common';\nimport { propEq } from '../common/hof';\nimport { Param } from '../params/param';\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\n\nvar PathNode =\n/** @class */\nfunction () {\n  function PathNode(stateOrNode) {\n    if (stateOrNode instanceof PathNode) {\n      var node = stateOrNode;\n      this.state = node.state;\n      this.paramSchema = node.paramSchema.slice();\n      this.paramValues = extend({}, node.paramValues);\n      this.resolvables = node.resolvables.slice();\n      this.views = node.views && node.views.slice();\n    } else {\n      var state = stateOrNode;\n      this.state = state;\n      this.paramSchema = state.parameters({\n        inherit: false\n      });\n      this.paramValues = {};\n      this.resolvables = state.resolvables.map(function (res) {\n        return res.clone();\n      });\n    }\n  }\n\n  PathNode.prototype.clone = function () {\n    return new PathNode(this);\n  };\n  /** Sets [[paramValues]] for the node, from the values of an object hash */\n\n\n  PathNode.prototype.applyRawParams = function (params) {\n    var getParamVal = function (paramDef) {\n      return [paramDef.id, paramDef.value(params[paramDef.id])];\n    };\n\n    this.paramValues = this.paramSchema.reduce(function (memo, pDef) {\n      return applyPairs(memo, getParamVal(pDef));\n    }, {});\n    return this;\n  };\n  /** Gets a specific [[Param]] metadata that belongs to the node */\n\n\n  PathNode.prototype.parameter = function (name) {\n    return find(this.paramSchema, propEq('id', name));\n  };\n  /**\n   * @returns true if the state and parameter values for another PathNode are\n   * equal to the state and param values for this PathNode\n   */\n\n\n  PathNode.prototype.equals = function (node, paramsFn) {\n    var diff = this.diff(node, paramsFn);\n    return diff && diff.length === 0;\n  };\n  /**\n   * Finds Params with different parameter values on another PathNode.\n   *\n   * Given another node (of the same state), finds the parameter values which differ.\n   * Returns the [[Param]] (schema objects) whose parameter values differ.\n   *\n   * Given another node for a different state, returns `false`\n   *\n   * @param node The node to compare to\n   * @param paramsFn A function that returns which parameters should be compared.\n   * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n   */\n\n\n  PathNode.prototype.diff = function (node, paramsFn) {\n    if (this.state !== node.state) return false;\n    var params = paramsFn ? paramsFn(this) : this.paramSchema;\n    return Param.changed(params, this.paramValues, node.paramValues);\n  };\n  /**\n   * Returns a clone of the PathNode\n   * @deprecated use instance method `node.clone()`\n   */\n\n\n  PathNode.clone = function (node) {\n    return node.clone();\n  };\n\n  return PathNode;\n}();\n\nexport { PathNode };","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,IAA7B,QAAuE,kBAAvE;AACA,SAASC,MAAT,QAAuB,eAAvB;AAGA,SAASC,KAAT,QAAsB,iBAAtB;AAIA;;;;;;;;AAOA;AAAA;AAAA;EAsBE,kBAAYC,WAAZ,EAA4B;IAC1B,IAAIA,WAAW,YAAYC,QAA3B,EAAqC;MACnC,IAAMC,IAAI,GAAaF,WAAvB;MACA,KAAKG,KAAL,GAAaD,IAAI,CAACC,KAAlB;MACA,KAAKC,WAAL,GAAmBF,IAAI,CAACE,WAAL,CAAiBC,KAAjB,EAAnB;MACA,KAAKC,WAAL,GAAmBX,MAAM,CAAC,EAAD,EAAKO,IAAI,CAACI,WAAV,CAAzB;MACA,KAAKC,WAAL,GAAmBL,IAAI,CAACK,WAAL,CAAiBF,KAAjB,EAAnB;MACA,KAAKG,KAAL,GAAaN,IAAI,CAACM,KAAL,IAAcN,IAAI,CAACM,KAAL,CAAWH,KAAX,EAA3B;IACD,CAPD,MAOO;MACL,IAAMF,KAAK,GAAgBH,WAA3B;MACA,KAAKG,KAAL,GAAaA,KAAb;MACA,KAAKC,WAAL,GAAmBD,KAAK,CAACM,UAAN,CAAiB;QAAEC,OAAO,EAAE;MAAX,CAAjB,CAAnB;MACA,KAAKJ,WAAL,GAAmB,EAAnB;MACA,KAAKC,WAAL,GAAmBJ,KAAK,CAACI,WAAN,CAAkBI,GAAlB,CAAsB,UAACC,GAAD,EAAI;QAAK,UAAG,CAACC,KAAJ;MAAW,CAA1C,CAAnB;IACD;EACF;;EAEDZ;IACE,OAAO,IAAIA,QAAJ,CAAa,IAAb,CAAP;EACD,CAFD;EAIA;;;EACAA,8CAAea,MAAf,EAAgC;IAC9B,IAAMC,WAAW,GAAG,UAACC,QAAD,EAAgB;MAAK,QAACA,QAAQ,CAACC,EAAV,EAAcD,QAAQ,CAACE,KAAT,CAAeJ,MAAM,CAACE,QAAQ,CAACC,EAAV,CAArB,CAAd;IAAkD,CAA3F;;IACA,KAAKX,WAAL,GAAmB,KAAKF,WAAL,CAAiBe,MAAjB,CAAwB,UAACC,IAAD,EAAOC,IAAP,EAAW;MAAK,iBAAU,CAACD,IAAD,EAAOL,WAAW,CAACM,IAAD,CAAlB,CAAV;IAAmC,CAA3E,EAA6E,EAA7E,CAAnB;IACA,OAAO,IAAP;EACD,CAJD;EAMA;;;EACApB,yCAAUqB,IAAV,EAAsB;IACpB,OAAOzB,IAAI,CAAC,KAAKO,WAAN,EAAmBN,MAAM,CAAC,IAAD,EAAOwB,IAAP,CAAzB,CAAX;EACD,CAFD;EAIA;;;;;;EAIArB,sCAAOC,IAAP,EAAuBqB,QAAvB,EAA6C;IAC3C,IAAMC,IAAI,GAAG,KAAKA,IAAL,CAAUtB,IAAV,EAAgBqB,QAAhB,CAAb;IACA,OAAOC,IAAI,IAAIA,IAAI,CAACC,MAAL,KAAgB,CAA/B;EACD,CAHD;EAKA;;;;;;;;;;;;;;EAYAxB,oCAAKC,IAAL,EAAqBqB,QAArB,EAA2C;IACzC,IAAI,KAAKpB,KAAL,KAAeD,IAAI,CAACC,KAAxB,EAA+B,OAAO,KAAP;IAE/B,IAAMW,MAAM,GAAYS,QAAQ,GAAGA,QAAQ,CAAC,IAAD,CAAX,GAAoB,KAAKnB,WAAzD;IACA,OAAOL,KAAK,CAAC2B,OAAN,CAAcZ,MAAd,EAAsB,KAAKR,WAA3B,EAAwCJ,IAAI,CAACI,WAA7C,CAAP;EACD,CALD;EAhEA;;;;;;EAIOL,iBAAQ,UAACC,IAAD,EAAe;IAAK,WAAI,CAACW,KAAL;EAAY,CAAxC;;EAkET;AAAC,CAlFD;;SAAaZ","names":["extend","applyPairs","find","propEq","Param","stateOrNode","PathNode","node","state","paramSchema","slice","paramValues","resolvables","views","parameters","inherit","map","res","clone","params","getParamVal","paramDef","id","value","reduce","memo","pDef","name","paramsFn","diff","length","changed"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\path\\@uirouter\\core\\path\\pathNode.ts"],"sourcesContent":["import { extend, applyPairs, find, allTrueR, pairs, arrayTuples } from '../common/common';\nimport { propEq } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\nimport { RawParams } from '../params/interface';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\n\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nexport class PathNode {\n  /** The state being entered, exited, or retained */\n  public state: StateObject;\n  /** The parameters declared on the state */\n  public paramSchema: Param[];\n  /** The parameter values that belong to the state */\n  public paramValues: { [key: string]: any };\n  /** The individual (stateful) resolvable objects that belong to the state */\n  public resolvables: Resolvable[];\n  /** The state's declared view configuration objects */\n  public views: ViewConfig[];\n\n  /**\n   * Returns a clone of the PathNode\n   * @deprecated use instance method `node.clone()`\n   */\n  static clone = (node: PathNode) => node.clone();\n\n  /** Creates a copy of a PathNode */\n  constructor(node: PathNode);\n  /** Creates a new (empty) PathNode for a State */\n  constructor(state: StateObject);\n  constructor(stateOrNode: any) {\n    if (stateOrNode instanceof PathNode) {\n      const node: PathNode = stateOrNode;\n      this.state = node.state;\n      this.paramSchema = node.paramSchema.slice();\n      this.paramValues = extend({}, node.paramValues);\n      this.resolvables = node.resolvables.slice();\n      this.views = node.views && node.views.slice();\n    } else {\n      const state: StateObject = stateOrNode;\n      this.state = state;\n      this.paramSchema = state.parameters({ inherit: false });\n      this.paramValues = {};\n      this.resolvables = state.resolvables.map((res) => res.clone());\n    }\n  }\n\n  clone() {\n    return new PathNode(this);\n  }\n\n  /** Sets [[paramValues]] for the node, from the values of an object hash */\n  applyRawParams(params: RawParams): PathNode {\n    const getParamVal = (paramDef: Param) => [paramDef.id, paramDef.value(params[paramDef.id])];\n    this.paramValues = this.paramSchema.reduce((memo, pDef) => applyPairs(memo, getParamVal(pDef)), {});\n    return this;\n  }\n\n  /** Gets a specific [[Param]] metadata that belongs to the node */\n  parameter(name: string): Param {\n    return find(this.paramSchema, propEq('id', name));\n  }\n\n  /**\n   * @returns true if the state and parameter values for another PathNode are\n   * equal to the state and param values for this PathNode\n   */\n  equals(node: PathNode, paramsFn?: GetParamsFn): boolean {\n    const diff = this.diff(node, paramsFn);\n    return diff && diff.length === 0;\n  }\n\n  /**\n   * Finds Params with different parameter values on another PathNode.\n   *\n   * Given another node (of the same state), finds the parameter values which differ.\n   * Returns the [[Param]] (schema objects) whose parameter values differ.\n   *\n   * Given another node for a different state, returns `false`\n   *\n   * @param node The node to compare to\n   * @param paramsFn A function that returns which parameters should be compared.\n   * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n   */\n  diff(node: PathNode, paramsFn?: GetParamsFn): Param[] | false {\n    if (this.state !== node.state) return false;\n\n    const params: Param[] = paramsFn ? paramsFn(this) : this.paramSchema;\n    return Param.changed(params, this.paramValues, node.paramValues);\n  }\n}\n\n/** @internal */\nexport type GetParamsFn = (pathNode: PathNode) => Param[];\n"]},"metadata":{},"sourceType":"module"}