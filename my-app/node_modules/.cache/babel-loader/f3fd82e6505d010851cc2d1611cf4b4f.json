{"ast":null,"code":"/** @publicapi @module directives */\n\n/** */\nimport { extend, filter, isDefined, isFunction, isString, kebobString, noop, parse, ResolveContext, tail, trace, unnestR } from '@uirouter/core';\nimport { ng as angular } from '../angular';\nimport { getLocals } from '../services';\nimport { Ng1ViewConfig } from '../statebuilders/views';\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\n\nexport var uiView; // eslint-disable-next-line prefer-const\n\nuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q', function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n  function getRenderer() {\n    return {\n      enter: function (element, target, cb) {\n        if (angular.version.minor > 2) {\n          $animate.enter(element, null, target).then(cb);\n        } else {\n          $animate.enter(element, null, target, cb);\n        }\n      },\n      leave: function (element, cb) {\n        if (angular.version.minor > 2) {\n          $animate.leave(element).then(cb);\n        } else {\n          $animate.leave(element, cb);\n        }\n      }\n    };\n  }\n\n  function configsEqual(config1, config2) {\n    return config1 === config2;\n  }\n\n  var rootData = {\n    $cfg: {\n      viewDecl: {\n        $context: $view._pluginapi._rootViewContext()\n      }\n    },\n    $uiView: {}\n  };\n  var directive = {\n    count: 0,\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var onloadExp = attrs['onload'] || '',\n            autoScrollExp = attrs['autoscroll'],\n            renderer = getRenderer(),\n            inherited = $element.inheritedData('$uiView') || rootData,\n            name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n        var previousEl, currentEl, currentScope, viewConfig;\n        var activeUIView = {\n          $type: 'ng1',\n          id: directive.count++,\n          name: name,\n          fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,\n          config: null,\n          configUpdated: configUpdatedCallback,\n\n          get creationContext() {\n            // The context in which this ui-view \"tag\" was created\n            var fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited); // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n            // See https://github.com/angular-ui/ui-router/issues/3355\n\n            var fromParentTag = parse('$uiView.creationContext')(inherited);\n            return fromParentTagConfig || fromParentTag;\n          }\n\n        };\n        trace.traceUIViewEvent('Linking', activeUIView);\n\n        function configUpdatedCallback(config) {\n          if (config && !(config instanceof Ng1ViewConfig)) return;\n          if (configsEqual(viewConfig, config)) return;\n          trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n          viewConfig = config;\n          updateView(config);\n        }\n\n        $element.data('$uiView', {\n          $uiView: activeUIView\n        });\n        updateView();\n        var unregister = $view.registerUIView(activeUIView);\n        scope.$on('$destroy', function () {\n          trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);\n          unregister();\n        });\n\n        function cleanupLastView() {\n          if (previousEl) {\n            trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            trace.traceUIViewEvent('Destroying scope', activeUIView);\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            var _viewData_1 = currentEl.data('$uiViewAnim');\n\n            trace.traceUIViewEvent('Animate out', _viewData_1);\n            renderer.leave(currentEl, function () {\n              _viewData_1.$$animLeave.resolve();\n\n              previousEl = null;\n            });\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(config) {\n          var newScope = scope.$new();\n          var animEnter = $q.defer(),\n              animLeave = $q.defer();\n          var $uiViewData = {\n            $cfg: config,\n            $uiView: activeUIView\n          };\n          var $uiViewAnim = {\n            $animEnter: animEnter.promise,\n            $animLeave: animLeave.promise,\n            $$animLeave: animLeave\n          };\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n\n          newScope.$emit('$viewContentLoading', name);\n          var cloned = $transclude(newScope, function (clone) {\n            clone.data('$uiViewAnim', $uiViewAnim);\n            clone.data('$uiView', $uiViewData);\n            renderer.enter(clone, $element, function onUIViewEnter() {\n              animEnter.resolve();\n              if (currentScope) currentScope.$emit('$viewContentAnimationEnded');\n\n              if (isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n          currentEl = cloned;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n\n          currentScope.$emit('$viewContentLoaded', config || viewConfig);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n  return directive;\n}];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q'];\n/** @hidden */\n\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q) {\n  var getControllerAs = parse('viewDecl.controllerAs');\n  var getResolveAs = parse('viewDecl.resolveAs');\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      tElement.empty();\n      return function (scope, $element) {\n        var data = $element.data('$uiView');\n\n        if (!data) {\n          $element.html(initial);\n          $compile($element.contents())(scope);\n          return;\n        }\n\n        var cfg = data.$cfg || {\n          viewDecl: {},\n          getTemplate: noop\n        };\n        var resolveCtx = cfg.path && new ResolveContext(cfg.path);\n        $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n        trace.traceUIViewFill(data.$uiView, $element.html());\n        var link = $compile($element.contents());\n        var controller = cfg.controller;\n        var controllerAs = getControllerAs(cfg);\n        var resolveAs = getResolveAs(cfg);\n        var locals = resolveCtx && getLocals(resolveCtx);\n        scope[resolveAs] = locals;\n\n        if (controller) {\n          var controllerInstance = $controller(controller, extend({}, locals, {\n            $scope: scope,\n            $element: $element\n          }));\n\n          if (controllerAs) {\n            scope[controllerAs] = controllerInstance;\n            scope[controllerAs][resolveAs] = locals;\n          } // TODO: Use $view service as a central point for registering component-level hooks\n          // Then, when a component is created, tell the $view service, so it can invoke hooks\n          // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n          // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\n\n          $element.data('$ngControllerController', controllerInstance);\n          $element.children().data('$ngControllerController', controllerInstance);\n          registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n        } // Wait for the component to appear in the DOM\n\n\n        if (isString(cfg.component)) {\n          var kebobName = kebobString(cfg.component);\n          var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", 'i');\n\n          var getComponentController = function () {\n            var directiveEl = [].slice.call($element[0].children).filter(function (el) {\n              return el && el.tagName && tagRegexp_1.exec(el.tagName);\n            });\n            return directiveEl && angular.element(directiveEl).data(\"$\" + cfg.component + \"Controller\");\n          };\n\n          var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n            if (!ctrlInstance) return;\n            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n            deregisterWatch_1();\n          });\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n/** @hidden */\n\n\nvar hasComponentImpl = typeof angular.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\n\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\n\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n  // Call $onInit() ASAP\n  if (isFunction(controllerInstance.$onInit) && !((cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl)) {\n    controllerInstance.$onInit();\n  }\n\n  var viewState = tail(cfg.path).state.self;\n  var hookOptions = {\n    bind: controllerInstance\n  }; // Add component-level hook for onUiParamsChanged\n\n  if (isFunction(controllerInstance.uiOnParamsChanged)) {\n    var resolveContext = new ResolveContext(cfg.path);\n    var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data; // Fire callback on any successful transition\n\n    var paramsUpdated = function ($transition$) {\n      // Exit early if the $transition$ is the same as the view was created within.\n      // Exit early if the $transition$ will exit the state the view is for.\n      if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1) return;\n      var toParams = $transition$.params('to');\n      var fromParams = $transition$.params('from');\n\n      var getNodeSchema = function (node) {\n        return node.paramSchema;\n      };\n\n      var toSchema = $transition$.treeChanges('to').map(getNodeSchema).reduce(unnestR, []);\n      var fromSchema = $transition$.treeChanges('from').map(getNodeSchema).reduce(unnestR, []); // Find the to params that have different values than the from params\n\n      var changedToParams = toSchema.filter(function (param) {\n        var idx = fromSchema.indexOf(param);\n        return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n      }); // Only trigger callback if a to param has changed or is new\n\n      if (changedToParams.length) {\n        var changedKeys_1 = changedToParams.map(function (x) {\n          return x.id;\n        }); // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n\n        var newValues = filter(toParams, function (val, key) {\n          return changedKeys_1.indexOf(key) !== -1;\n        });\n        controllerInstance.uiOnParamsChanged(newValues, $transition$);\n      }\n    };\n\n    $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n  } // Add component-level hook for uiCanExit\n\n\n  if (isFunction(controllerInstance.uiCanExit)) {\n    var id_1 = _uiCanExitId++;\n    var cacheProp_1 = '_uiCanExitIds'; // Returns true if a redirect transition already answered truthy\n\n    var prevTruthyAnswer_1 = function (trans) {\n      return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n    }; // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n\n\n    var wrappedHook = function (trans) {\n      var promise;\n      var ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n\n      if (!prevTruthyAnswer_1(trans)) {\n        promise = $q.when(controllerInstance.uiCanExit(trans));\n        promise.then(function (val) {\n          return ids[id_1] = val !== false;\n        });\n      }\n\n      return promise;\n    };\n\n    var criteria = {\n      exiting: viewState.name\n    };\n    $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n  }\n}\n\nangular.module('ui.router.state').directive('uiView', uiView);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);","map":{"version":3,"mappings":"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","names":["extend","filter","isDefined","isFunction","isString","kebobString","noop","parse","ResolveContext","tail","trace","unnestR","ng","angular","getLocals","Ng1ViewConfig","uiView","$ViewDirective","$view","$animate","$uiViewScroll","$interpolate","$q","getRenderer","enter","element","target","cb","version","minor","then","leave","configsEqual","config1","config2","rootData","$cfg","viewDecl","$context","_pluginapi","_rootViewContext","$uiView","directive","count","restrict","terminal","priority","transclude","compile","tElement","tAttrs","$transclude","scope","$element","attrs","onloadExp","autoScrollExp","renderer","inherited","inheritedData","name","previousEl","currentEl","currentScope","viewConfig","activeUIView","$type","id","fqn","config","configUpdated","configUpdatedCallback","creationContext","fromParentTagConfig","fromParentTag","traceUIViewEvent","traceUIViewConfigUpdated","updateView","data","unregister","registerUIView","$on","cleanupLastView","remove","$destroy","_viewData_1","$$animLeave","resolve","newScope","$new","animEnter","defer","animLeave","$uiViewData","$uiViewAnim","$animEnter","promise","$animLeave","$emit","cloned","clone","onUIViewEnter","$eval","$ViewDirectiveFill","$inject","$compile","$controller","$transitions","getControllerAs","getResolveAs","initial","html","empty","contents","cfg","getTemplate","resolveCtx","path","traceUIViewFill","link","controller","controllerAs","resolveAs","locals","controllerInstance","$scope","children","registerControllerCallbacks","component","kebobName","tagRegexp_1","RegExp","getComponentController","directiveEl","slice","call","el","tagName","exec","deregisterWatch_1","$watch","ctrlInstance","hasComponentImpl","module","_uiCanExitId","$onInit","componentProvider","viewState","state","self","hookOptions","bind","uiOnParamsChanged","resolveContext","viewCreationTrans_1","getResolvable","paramsUpdated","$transition$","exiting","indexOf","toParams","params","fromParams","getNodeSchema","node","paramSchema","toSchema","treeChanges","map","reduce","fromSchema","changedToParams","param","idx","type","equals","length","changedKeys_1","x","newValues","val","key","onSuccess","uiCanExit","id_1","cacheProp_1","prevTruthyAnswer_1","trans","redirectedFrom","wrappedHook","ids","when","criteria","onBefore"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\angularjs\\lib-esm\\directives\\@uirouter\\angularjs\\directives\\viewDirective.ts"],"sourcesContent":["/** @publicapi @module directives */ /** */\nimport {\n  $QLike,\n  ActiveUIView,\n  extend,\n  filter,\n  HookRegOptions,\n  isDefined,\n  isFunction,\n  isString,\n  kebobString,\n  noop,\n  Obj,\n  Param,\n  parse,\n  PathNode,\n  ResolveContext,\n  StateDeclaration,\n  tail,\n  trace,\n  Transition,\n  TransitionService,\n  TypedMap,\n  unnestR,\n  ViewService,\n} from '@uirouter/core';\nimport { IAugmentedJQuery, IInterpolateService, IScope, ITranscludeFunction } from 'angular';\nimport { ng as angular } from '../angular';\nimport { Ng1Controller, Ng1StateDeclaration } from '../interface';\nimport { getLocals } from '../services';\nimport { Ng1ViewConfig } from '../statebuilders/views';\nimport { ng1_directive } from './stateDirectives';\n\n/** @hidden */\nexport type UIViewData = {\n  $cfg: Ng1ViewConfig;\n  $uiView: ActiveUIView;\n};\n\n/** @hidden */\nexport type UIViewAnimData = {\n  $animEnter: Promise<any>;\n  $animLeave: Promise<any>;\n  $$animLeave: { resolve: () => any }; // \"deferred\"\n};\n\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nexport let uiView: ng1_directive;\n// eslint-disable-next-line prefer-const\nuiView = [\n  '$view',\n  '$animate',\n  '$uiViewScroll',\n  '$interpolate',\n  '$q',\n  function $ViewDirective(\n    $view: ViewService,\n    $animate: any,\n    $uiViewScroll: any,\n    $interpolate: IInterpolateService,\n    $q: $QLike\n  ) {\n    function getRenderer() {\n      return {\n        enter: function (element: JQuery, target: any, cb: Function) {\n          if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function (element: JQuery, cb: Function) {\n          if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        },\n      };\n    }\n\n    function configsEqual(config1: Ng1ViewConfig, config2: Ng1ViewConfig) {\n      return config1 === config2;\n    }\n\n    const rootData = {\n      $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n      $uiView: {},\n    };\n\n    const directive = {\n      count: 0,\n      restrict: 'ECA',\n      terminal: true,\n      priority: 400,\n      transclude: 'element',\n      compile: function (tElement: JQuery, tAttrs: Obj, $transclude: ITranscludeFunction) {\n        return function (scope: IScope, $element: IAugmentedJQuery, attrs: Obj) {\n          const onloadExp = attrs['onload'] || '',\n            autoScrollExp = attrs['autoscroll'],\n            renderer = getRenderer(),\n            inherited = $element.inheritedData('$uiView') || rootData,\n            name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n\n          let previousEl: JQuery, currentEl: JQuery, currentScope: IScope, viewConfig: Ng1ViewConfig;\n\n          const activeUIView: ActiveUIView = {\n            $type: 'ng1',\n            id: directive.count++, // Global sequential ID for ui-view tags added to DOM\n            name: name, // ui-view name (<div ui-view=\"name\"></div>\n            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name, // fully qualified name, describes location in DOM\n            config: null, // The ViewConfig loaded (from a state.views definition)\n            configUpdated: configUpdatedCallback, // Called when the matching ViewConfig changes\n            get creationContext() {\n              // The context in which this ui-view \"tag\" was created\n              const fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);\n              // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n              // See https://github.com/angular-ui/ui-router/issues/3355\n              const fromParentTag = parse('$uiView.creationContext')(inherited);\n              return fromParentTagConfig || fromParentTag;\n            },\n          };\n\n          trace.traceUIViewEvent('Linking', activeUIView);\n\n          function configUpdatedCallback(config?: Ng1ViewConfig) {\n            if (config && !(config instanceof Ng1ViewConfig)) return;\n            if (configsEqual(viewConfig, config)) return;\n            trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n\n            viewConfig = config;\n            updateView(config);\n          }\n\n          $element.data('$uiView', { $uiView: activeUIView });\n\n          updateView();\n\n          const unregister = $view.registerUIView(activeUIView);\n          scope.$on('$destroy', function () {\n            trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);\n            unregister();\n          });\n\n          function cleanupLastView() {\n            if (previousEl) {\n              trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));\n              previousEl.remove();\n              previousEl = null;\n            }\n\n            if (currentScope) {\n              trace.traceUIViewEvent('Destroying scope', activeUIView);\n              currentScope.$destroy();\n              currentScope = null;\n            }\n\n            if (currentEl) {\n              const _viewData = currentEl.data('$uiViewAnim');\n              trace.traceUIViewEvent('Animate out', _viewData);\n              renderer.leave(currentEl, function () {\n                _viewData.$$animLeave.resolve();\n                previousEl = null;\n              });\n\n              previousEl = currentEl;\n              currentEl = null;\n            }\n          }\n\n          function updateView(config?: Ng1ViewConfig) {\n            const newScope = scope.$new();\n            const animEnter = $q.defer(),\n              animLeave = $q.defer();\n\n            const $uiViewData: UIViewData = {\n              $cfg: config,\n              $uiView: activeUIView,\n            };\n\n            const $uiViewAnim: UIViewAnimData = {\n              $animEnter: animEnter.promise,\n              $animLeave: animLeave.promise,\n              $$animLeave: animLeave,\n            };\n\n            /**\n             * @ngdoc event\n             * @name ui.router.state.directive:ui-view#$viewContentLoading\n             * @eventOf ui.router.state.directive:ui-view\n             * @eventType emits on ui-view directive scope\n             * @description\n             *\n             * Fired once the view **begins loading**, *before* the DOM is rendered.\n             *\n             * @param {Object} event Event object.\n             * @param {string} viewName Name of the view.\n             */\n            newScope.$emit('$viewContentLoading', name);\n\n            const cloned = $transclude(newScope, function (clone) {\n              clone.data('$uiViewAnim', $uiViewAnim);\n              clone.data('$uiView', $uiViewData);\n              renderer.enter(clone, $element, function onUIViewEnter() {\n                animEnter.resolve();\n                if (currentScope) currentScope.$emit('$viewContentAnimationEnded');\n\n                if ((isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {\n                  $uiViewScroll(clone);\n                }\n              });\n\n              cleanupLastView();\n            });\n\n            currentEl = cloned;\n            currentScope = newScope;\n            /**\n             * @ngdoc event\n             * @name ui.router.state.directive:ui-view#$viewContentLoaded\n             * @eventOf ui.router.state.directive:ui-view\n             * @eventType emits on ui-view directive scope\n             * @description           *\n             * Fired once the view is **loaded**, *after* the DOM is rendered.\n             *\n             * @param {Object} event Event object.\n             */\n            currentScope.$emit('$viewContentLoaded', config || viewConfig);\n            currentScope.$eval(onloadExp);\n          }\n        };\n      },\n    };\n\n    return directive;\n  },\n];\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q'];\n\n/** @hidden */\nfunction $ViewDirectiveFill(\n  $compile: angular.ICompileService,\n  $controller: angular.IControllerService,\n  $transitions: TransitionService,\n  $view: ViewService,\n  $q: angular.IQService\n) {\n  const getControllerAs = parse('viewDecl.controllerAs');\n  const getResolveAs = parse('viewDecl.resolveAs');\n\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement: JQuery) {\n      const initial = tElement.html();\n      tElement.empty();\n\n      return function (scope: IScope, $element: JQuery) {\n        const data: UIViewData = $element.data('$uiView');\n        if (!data) {\n          $element.html(initial);\n          $compile($element.contents() as any)(scope);\n          return;\n        }\n\n        const cfg: Ng1ViewConfig = data.$cfg || <any>{ viewDecl: {}, getTemplate: noop };\n        const resolveCtx: ResolveContext = cfg.path && new ResolveContext(cfg.path);\n        $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n        trace.traceUIViewFill(data.$uiView, $element.html());\n\n        const link = $compile($element.contents() as any);\n        const controller = cfg.controller as angular.IControllerService;\n        const controllerAs: string = getControllerAs(cfg);\n        const resolveAs: string = getResolveAs(cfg);\n        const locals = resolveCtx && getLocals(resolveCtx);\n\n        scope[resolveAs] = locals;\n\n        if (controller) {\n          const controllerInstance = <Ng1Controller>(\n            $controller(controller, extend({}, locals, { $scope: scope, $element: $element }))\n          );\n          if (controllerAs) {\n            scope[controllerAs] = controllerInstance;\n            scope[controllerAs][resolveAs] = locals;\n          }\n\n          // TODO: Use $view service as a central point for registering component-level hooks\n          // Then, when a component is created, tell the $view service, so it can invoke hooks\n          // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n          // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\n          $element.data('$ngControllerController', controllerInstance);\n          $element.children().data('$ngControllerController', controllerInstance);\n\n          registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n        }\n\n        // Wait for the component to appear in the DOM\n        if (isString(cfg.component)) {\n          const kebobName = kebobString(cfg.component);\n          const tagRegexp = new RegExp(`^(x-|data-)?${kebobName}$`, 'i');\n\n          const getComponentController = () => {\n            const directiveEl = [].slice\n              .call($element[0].children)\n              .filter((el: Element) => el && el.tagName && tagRegexp.exec(el.tagName));\n\n            return directiveEl && angular.element(directiveEl).data(`$${cfg.component}Controller`);\n          };\n\n          const deregisterWatch = scope.$watch(getComponentController, function (ctrlInstance) {\n            if (!ctrlInstance) return;\n            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n            deregisterWatch();\n          });\n        }\n\n        link(scope);\n      };\n    },\n  };\n}\n\n/** @hidden */\nconst hasComponentImpl = typeof (angular as any).module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nlet _uiCanExitId = 0;\n\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks(\n  $q: angular.IQService,\n  $transitions: TransitionService,\n  controllerInstance: Ng1Controller,\n  $scope: IScope,\n  cfg: Ng1ViewConfig\n) {\n  // Call $onInit() ASAP\n  if (\n    isFunction(controllerInstance.$onInit) &&\n    !((cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl)\n  ) {\n    controllerInstance.$onInit();\n  }\n\n  const viewState: Ng1StateDeclaration = tail(cfg.path).state.self;\n\n  const hookOptions: HookRegOptions = { bind: controllerInstance };\n  // Add component-level hook for onUiParamsChanged\n  if (isFunction(controllerInstance.uiOnParamsChanged)) {\n    const resolveContext: ResolveContext = new ResolveContext(cfg.path);\n    const viewCreationTrans = resolveContext.getResolvable('$transition$').data;\n\n    // Fire callback on any successful transition\n    const paramsUpdated = ($transition$: Transition) => {\n      // Exit early if the $transition$ is the same as the view was created within.\n      // Exit early if the $transition$ will exit the state the view is for.\n      if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(viewState as StateDeclaration) !== -1)\n        return;\n\n      const toParams = $transition$.params('to') as TypedMap<any>;\n      const fromParams = $transition$.params<TypedMap<any>>('from') as TypedMap<any>;\n      const getNodeSchema = (node: PathNode) => node.paramSchema;\n      const toSchema: Param[] = $transition$.treeChanges('to').map(getNodeSchema).reduce(unnestR, []);\n      const fromSchema: Param[] = $transition$.treeChanges('from').map(getNodeSchema).reduce(unnestR, []);\n\n      // Find the to params that have different values than the from params\n      const changedToParams = toSchema.filter((param: Param) => {\n        const idx = fromSchema.indexOf(param);\n        return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n      });\n\n      // Only trigger callback if a to param has changed or is new\n      if (changedToParams.length) {\n        const changedKeys: string[] = changedToParams.map((x) => x.id);\n        // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n        const newValues = filter(toParams, (val, key) => changedKeys.indexOf(key) !== -1);\n        controllerInstance.uiOnParamsChanged(newValues, $transition$);\n      }\n    };\n    $scope.$on('$destroy', <any>$transitions.onSuccess({}, paramsUpdated, hookOptions));\n  }\n\n  // Add component-level hook for uiCanExit\n  if (isFunction(controllerInstance.uiCanExit)) {\n    const id = _uiCanExitId++;\n    const cacheProp = '_uiCanExitIds';\n\n    // Returns true if a redirect transition already answered truthy\n    const prevTruthyAnswer = (trans: Transition) =>\n      !!trans && ((trans[cacheProp] && trans[cacheProp][id] === true) || prevTruthyAnswer(trans.redirectedFrom()));\n\n    // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n    const wrappedHook = (trans: Transition) => {\n      let promise;\n      const ids = (trans[cacheProp] = trans[cacheProp] || {});\n\n      if (!prevTruthyAnswer(trans)) {\n        promise = $q.when(controllerInstance.uiCanExit(trans));\n        promise.then((val) => (ids[id] = val !== false));\n      }\n      return promise;\n    };\n\n    const criteria = { exiting: viewState.name };\n    $scope.$on('$destroy', <any>$transitions.onBefore(criteria, wrappedHook, hookOptions));\n  }\n}\n\nangular.module('ui.router.state').directive('uiView', <any>uiView);\nangular.module('ui.router.state').directive('uiView', <any>$ViewDirectiveFill);\n"]},"metadata":{},"sourceType":"module"}