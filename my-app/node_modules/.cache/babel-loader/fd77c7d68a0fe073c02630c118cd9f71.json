{"ast":null,"code":"import { isString } from '../common/predicates';\nimport { values } from '../common/common';\nimport { safeConsole } from '../common/safeConsole';\n\nvar StateMatcher =\n/** @class */\nfunction () {\n  function StateMatcher(_states) {\n    this._states = _states;\n  }\n\n  StateMatcher.prototype.isRelative = function (stateName) {\n    stateName = stateName || '';\n    return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;\n  };\n\n  StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n    if (matchGlob === void 0) {\n      matchGlob = true;\n    }\n\n    if (!stateOrName && stateOrName !== '') return undefined;\n    var isStr = isString(stateOrName);\n    var name = isStr ? stateOrName : stateOrName.name;\n    if (this.isRelative(name)) name = this.resolvePath(name, base);\n    var state = this._states[name];\n\n    if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {\n      return state;\n    } else if (isStr && matchGlob) {\n      var _states = values(this._states);\n\n      var matches = _states.filter(function (_state) {\n        return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name);\n      });\n\n      if (matches.length > 1) {\n        safeConsole.error(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) {\n          return match.name;\n        }));\n      }\n\n      return matches[0];\n    }\n\n    return undefined;\n  };\n\n  StateMatcher.prototype.resolvePath = function (name, base) {\n    if (!base) throw new Error(\"No reference point given for path '\" + name + \"'\");\n    var baseState = this.find(base);\n    var splitName = name.split('.');\n    var pathLength = splitName.length;\n    var i = 0,\n        current = baseState;\n\n    for (; i < pathLength; i++) {\n      if (splitName[i] === '' && i === 0) {\n        current = baseState;\n        continue;\n      }\n\n      if (splitName[i] === '^') {\n        if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n        current = current.parent;\n        continue;\n      }\n\n      break;\n    }\n\n    var relName = splitName.slice(i).join('.');\n    return current.name + (current.name && relName ? '.' : '') + relName;\n  };\n\n  return StateMatcher;\n}();\n\nexport { StateMatcher };","map":{"version":3,"mappings":"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","names":["isString","values","safeConsole","_states","StateMatcher","stateName","indexOf","stateOrName","base","matchGlob","undefined","isStr","name","isRelative","resolvePath","state","self","matches","filter","_state","__stateObjectCache","nameGlob","length","error","map","match","Error","baseState","find","splitName","split","pathLength","i","current","parent","relName","slice","join"],"sources":["C:\\Users\\huang\\node_modules\\@uirouter\\core\\lib-esm\\state\\@uirouter\\core\\state\\stateMatcher.ts"],"sourcesContent":["import { isString } from '../common/predicates';\nimport { StateOrName } from './interface';\nimport { StateObject } from './stateObject';\nimport { values } from '../common/common';\nimport { safeConsole } from '../common/safeConsole';\n\nexport class StateMatcher {\n  constructor(private _states: { [key: string]: StateObject }) {}\n\n  isRelative(stateName: string) {\n    stateName = stateName || '';\n    return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;\n  }\n\n  find(stateOrName: StateOrName, base?: StateOrName, matchGlob = true): StateObject {\n    if (!stateOrName && stateOrName !== '') return undefined;\n    const isStr = isString(stateOrName);\n    let name: string = isStr ? stateOrName : (<any>stateOrName).name;\n\n    if (this.isRelative(name)) name = this.resolvePath(name, base);\n    const state = this._states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    } else if (isStr && matchGlob) {\n      const _states = values(this._states);\n      const matches = _states.filter(\n        (_state) => _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name)\n      );\n\n      if (matches.length > 1) {\n        safeConsole.error(\n          `stateMatcher.find: Found multiple matches for ${name} using glob: `,\n          matches.map((match) => match.name)\n        );\n      }\n      return matches[0];\n    }\n    return undefined;\n  }\n\n  resolvePath(name: string, base: StateOrName) {\n    if (!base) throw new Error(`No reference point given for path '${name}'`);\n\n    const baseState: StateObject = this.find(base);\n\n    const splitName = name.split('.');\n    const pathLength = splitName.length;\n    let i = 0,\n      current = baseState;\n\n    for (; i < pathLength; i++) {\n      if (splitName[i] === '' && i === 0) {\n        current = baseState;\n        continue;\n      }\n      if (splitName[i] === '^') {\n        if (!current.parent) throw new Error(`Path '${name}' not valid for state '${baseState.name}'`);\n        current = current.parent;\n        continue;\n      }\n      break;\n    }\n    const relName = splitName.slice(i).join('.');\n    return current.name + (current.name && relName ? '.' : '') + relName;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}